{
  "id": 13,
  "title": "Hyperscope_Development_Plan",
  "body": "Great plan. Below is a tightened, decision-oriented expansion with concrete defaults, acceptance criteria, and low-risk implementation details. If you confirm your lineage (Engelbart deep hypertext vs. P2P browser), I can tailor importers, link syntax, and the MVP demo script precisely.\n\nRecommended defaults to reduce decision thrash\n- Differentiator: Engelbart-style granular links and transclusions for local knowledge bases that remain stable across edits.\n- MVP workflows:\n  1) Create and share deep links into Markdown/HTML (paragraph/line/range anchors) that remain stable after edits.\n  2) View multiple synchronized lenses of the same document (outline + full text + backlinks) and perform transclusions.\n- Tech stack: Rust core + Tauri GUI + shared CLI/TUI (Ratatui). Plugins via JSON-RPC over stdio (language-agnostic, easy to version). Static-site exporter for shareable, read-only deep links on the web.\n\n1) Clarify value and scope\n- Crisp promise: \u201cStable, granular links and transclusions for your documents\u2014links that don\u2019t break when text moves.\u201d\n- What uniquely good looks like:\n  - Deterministic, stable IDs at block/paragraph/sentence level.\n  - Range addressing with robust re-anchoring after edits (fuzzy matching).\n  - Multi-view lenses: outline, backlinks, and \u201ctransclusion pane.\u201d\n- Acceptance criteria:\n  - Paste a deep link from Hyperscope into Slack/Docs; recipients can open the exact span later even after edits.\n  - Import a folder of Markdown and instantly navigate via generated outline/backlinks.\n  - Transclude a section of Doc A into Doc B and see live updates when A changes.\n- 3-minute demo script:\n  1) Open sample corpus; click \u201cDeep Links 101.md.\u201d\n  2) Copy link to paragraph 3; paste in a second window; navigate; highlight shows.\n  3) Edit document (move paragraphs); reopen the link; highlight snaps to the same logical paragraph.\n  4) Open split view: outline on left, text on right; click outline node; selection syncs.\n  5) Create a new note and transclude \u201cDesign/Addressing.md \u00a7Stability\u201d; show it stays in sync.\n\n2) Technical strategy for a small, fast binary\n- Core language: Rust (memory safety, great parsers, small static binaries).\n- Architecture:\n  - hyperscope-core (no GUI):\n    - parsers: Markdown (pulldown-cmark), HTML5 (html5ever), OPML (quick-xml), JSON.\n    - segmenter/ID assigner: stable block IDs + sentence IDs; content-defined boundaries (rolling hash) plus heuristics to survive edits.\n    - re-anchoring: fuzzy locator using context windows + ID hint; diff-match-patch fallback.\n    - storage/index: SQLite (rusqlite) or sled for speed; initial index stored in .hs/index.db per workspace.\n    - addressing: hs:// scheme + fragment syntax; also file:// fallback with #g= anchor.\n    - export: HTML with embedded anchors and a tiny JS highlighter for ranges.\n  - hs-cli: import, index, link-create, link-resolve, export.\n  - hs-tui: Ratatui-based viewer (outline + text + backlinks).\n  - hs-gui: Tauri shell wrapping the core with native menus, system handlers for hs: links.\n- Plugin system:\n  - Transport: JSON-RPC 2.0 over stdio subprocess (like Language Server Protocol).\n  - Capabilities: content importers, renderers, link resolvers, commands.\n  - Versioning: semantic versioned Core API v1 (JSON schemas), feature flags.\n  - Security: capability manifest; plugins run with restricted FS access; no network unless granted.\n- WebAssembly companion:\n  - Build hyperscope-core-wasm for in-browser demo (read-only viewer + deep-links), but focus dev on the binary.\n- Performance budgets:\n  - Binary \u2264 50 MB macOS, \u2264 40 MB Linux; cold start \u2264 500 ms.\n  - Index 10k-line Markdown repo in \u2264 10 s; steady-state navigation latency \u2264 30 ms.\n\n3) Packaging and distribution that feel mainstream\n- Build matrix: macOS x64/arm64, Windows x64/arm64, Linux x64/arm64.\n- Tools:\n  - cargo-dist for cross-OS releases and artifacts.\n  - Tauri bundler for DMG/MSI/AppImage; Flatpak manifest via flatpak-builder.\n  - Homebrew formula (tap), Scoop manifest, winget package, apt repo later if demand.\n- Code signing/notarization:\n  - macOS: Developer ID cert + notarytool; hardened runtime.\n  - Windows: EV Code Signing cert + signtool + SmartScreen reputation build-up.\n  - Linux: detached signatures + SBOM; no root installers by default.\n- Auto-updates:\n  - Tauri\u2019s autoUpdater with your signed channel for macOS/Windows.\n  - Linux: opt-in via AppImage update or Flatpak; respect distro policies.\n- Reproducibility:\n  - Deterministic builds with cargo dist; supply SHA256 and minisign/sigstore signatures.\n  - SBOM via cargo auditable and/or Syft; publish with releases.\n\n4) Compatibility and data pathways\n- Import:\n  - Legacy Hyperscope/Augment: implement a dedicated importer and link translator early; publish mapping rules.\n  - Markdown/HTML/OPML/JSON: initial set. For Markdown, support CommonMark + frontmatter metadata.\n- Export:\n  - HTML static site: preserves anchors, adds highlighting script for ranges, and \u201copen in Hyperscope\u201d buttons.\n  - Markdown with embedded stable IDs as HTML comments for round-tripping.\n- Addressing scheme:\n  - hs://workspace/doc?view=reader#b=g:PARA-GUID,s=offset..offset\n  - Back-compat: recognize legacy link syntax; translate to new scheme and store a redirect table.\n- Migration tool:\n  - hs-cli migrate --input <path> --legacy-type augment|hyperscope-old --dry-run\n  - Generates a report of translated links and mismatches.\n\n5) Product polish that reduces friction\n- First-run:\n  - Sample corpus: three short docs\u2014Deep Links 101, Transclusion Showcase, Multi-View Tour.\n  - 60-second guided tour modal; \u201ccopy deep link\u201d CTA appears contextually.\n- Defaults:\n  - Keyboard-first: vim-like and macOS-friendly shortcuts; quick-open (Cmd/Ctrl-P); command palette (Cmd/Ctrl-Shift-P).\n- Crash reporting/telemetry:\n  - Sentry or Glitchtip for crashes; opt-in toggle during onboarding; public schema and retention policy.\n- Performance monitoring:\n  - Built-in metrics panel (hidden) to show cold start, index time; for dev support.\n\n6) Security and privacy\n- No background daemons. Tauri sandbox; file access only after user selection (scoped directories).\n- Offline by default; network only for updates if opted in.\n- Supply SBOMs; CI runs cargo audit and osv-scanner; weekly dependency updates PRs.\n- Signed releases on all platforms.\n\n7) Engineering operations\n- CI/CD (GitHub Actions):\n  - Lint (clippy), fmt, unit/integration tests, wasm build check, fuzz corpus smoke test.\n  - Cross-compile, sign, notarize, upload artifacts on tag.\n- Testing:\n  - Golden tests for importers and anchor generation.\n  - Fuzz parsers and re-anchoring (cargo-fuzz); seed with real docs.\n  - Cross-platform UI smoke tests (Playwright with Tauri driver).\n- Process:\n  - Issue templates (bug, feature), discussion for proposals.\n  - Tiny RFCs for core API changes (one-pager: problem, design, migration).\n  - Release cadence: monthly minor; patch as needed; changelog with \u201cmigration notes.\u201d\n\n8) Documentation and learning\n- Docs stack: Docusaurus or mdBook; host on GitHub Pages.\n- Quickstart: install, import folder, copy a deep link, share, export to web.\n- 10 task recipes:\n  - Make a paragraph link; link a text range; transclude; compare two versions; build backlinks; export static site; install plugin; write a plugin; VS Code command; intercept hs: links in browser.\n- \u201cDeep Links 101\u201d tutorial:\n  - Concepts: stable IDs, ranges, re-anchoring, link rot prevention.\n  - How it maps to Markdown/HTML.\n- API docs:\n  - JSON-RPC schemas with examples; example plugin repo (TypeScript and Rust); starter template.\n\n9) Community and governance\n- Keep core tiny; encourage plugins for importers/renderers/integrations.\n- Governance:\n  - Maintainers group; CODEOWNERS; weekly triage; public roadmap; \u201cGood first issues.\u201d\n  - DCO or CLA? Prefer DCO + CoC (e.g., Contributor Covenant).\n- Community:\n  - Monthly office hours on Zoom/Jitsi; recordings on YouTube; notes in repo.\n  - Plugin registry via a curated README and later a simple directory JSON.\n\n10) Awareness and adoption\n- Story: \u201cBring deep, stable links and transclusions to your knowledge base.\u201d\n- Landing page:\n  - One-liner, three GIFs (deep link surviving edits, transclusion, multi-view), download buttons.\n- Launch playbook:\n  - Pre-brief a few friendly reviewers; publish to HN/Reddit/Dev.to; 3\u20135 minute demo video; short thread on X/BlueSky; crosspost to knowledge management communities.\n- Seed integrations:\n  - VS Code extension: \u201cCopy deep link,\u201d \u201cOpen hs: link,\u201d inline decorations for anchors.\n  - Obsidian plugin: context menu for deep link; transclusion block.\n  - Browser extension: register hs: protocol handler; fallback resolver to local app via custom URL scheme.\n- Network effects:\n  - \u201cExport to web\u201d with shareable links that open in browser and suggest \u201cOpen in Hyperscope\u201d if installed.\n\n11) Funding and sustainability\n- License:\n  - Core: MPL-2.0 (business-friendly, keeps improvements to core shared).\n  - Optional paid: team features (shared indexes, admin policy, SSO, managed updates).\n- Funding channels:\n  - GitHub Sponsors tiers; NLnet/NGI, Prototype Fund, Code for Science & Society microgrants.\n  - Plugin bounties for key importers (Notion/Confluence/OneNote).\n- Lightweight Pro plan:\n  - $5\u201310/month solo: priority updates, advanced export themes, power-user features.\n  - Team: per-seat, adds collaboration server later (not in MVP).\n\nSuggested 6\u2011month phased roadmap (expanded)\n- Month 0\u20131 (Foundations)\n  - Decide lineage (Engelbart default). Define MVP workflows and acceptance tests.\n  - Repos: hyperscope-core, hs-cli, hs-tui, hs-gui, plugins/examples, website/docs.\n  - Implement core: Markdown/HTML import, stable IDs, basic re-anchoring, SQLite index.\n  - TUI viewer with outline + text and \u201ccopy deep link.\u201d\n  - CI: build matrix, tests, fuzz harness scaffold, cargo audit.\n  - Deliverable: pre-alpha CLI/TUI; resolves and opens deep links locally.\n\n- Month 2\u20133 (Productize)\n  - Tauri GUI with split views; hs:// protocol handler; copy/open links system-wide.\n  - Static exporter (HTML + anchors + highlighter).\n  - Packagers: DMG notarized, MSI with winget, AppImage + Flatpak; Homebrew/Scoop.\n  - Reproducible builds, code signing, SBOMs; crash reporting opt-in.\n  - Docs site, sample corpus, 60s onboarding.\n  - Early adopter pre-release; collect feedback on anchoring robustness.\n  - Deliverable: beta installers; landing page draft; demo data.\n\n- Month 4\u20135 (Ecosystem + quality)\n  - Plugin API v0 via JSON-RPC; example importers (OPML), formatter plugin.\n  - Accessibility pass; keyboard map solidified; performance pass on index and re-anchoring.\n  - Integrations: VS Code extension and Obsidian plugin.\n  - Browser extension for hs: protocol; telemetry schema published.\n  - Deliverable: RC build; 3 GIFs and demo video recorded.\n\n- Month 6 (Relaunch)\n  - 1.0 release with installers; landing page live.\n  - Launch campaign; office hours kickoff; roadmap published.\n  - Establish monthly releases; triage routine; solicit plugin proposals/bounties.\n\nKPIs and guardrails\n- Functionality:\n  - \u2265 95% of deep links survive typical edits in test corpus (move, split, merge, typo).\n  - Index time: \u2264 10 s for 1,000 Markdown files (~10 MB total).\n- UX:\n  - Cold start \u2264 500 ms; deep link open \u2264 300 ms.\n  - Onboarding completion rate \u2265 60% for new installs (opt-in metrics).\n- Adoption:\n  - 1k downloads in 30 days post-launch; 3+ community plugins in 60 days.\n- Quality:\n  - Crash-free sessions \u2265 99%; zero critical security advisories open > 7 days.\n\nRisk mitigations\n- Plugin ABI churn: fix by JSON-RPC schemas and feature flags; avoid in-process ABI until 2.0.\n- Code signing friction: start application now for Apple/Windows certs; use a CI secret rotation plan.\n- Anchoring edge cases: ship a \u201cReport bad anchor\u201d tool with anonymized diff capture (opt-in) and build a fuzz corpus.\n\nConcrete link/addressing proposal (initial)\n- Scheme: hs://workspace/doc-id#b=<BLOCK_GUID>&r=<START..END>&v=<VIEW>\n  - BLOCK_GUID is a stable 128-bit hex derived from normalized text and structural context.\n  - r is character offsets within the block; optional.\n  - Fallback for web export: https://your-site/doc#b=<BLOCK_GUID>&r=... with JS to highlight and scroll.\n- ID generation:\n  - Normalize whitespace; compute rolling hash for boundaries; GUID = hash(block_text + parent_outline_path).\n  - Store a sidecar .hsids.json mapping for plaintext formats to avoid modifying files.\n- Re-anchoring:\n  - Attempt GUID match; if missing, fuzzy match with context window (prev/next block hashes, top-k text shingles).\n\nTeam and effort (minimal viable team)\n- 1 senior Rust engineer (core/index/anchoring).\n- 1 app engineer (Tauri + integrations).\n- 0.5 dev rel/PM (docs, landing page, release ops).\n- Contractors/volunteers for plugins and packaging help.\n\nOpen question to tailor precisely\n- Which Hyperscope lineage are you targeting?\n  - Engelbart-style granular hypertext: we proceed as above; prioritize import/migration and deep link stability.\n  - SSB/Hypercore P2P browser: we would swap storage/index for append-only logs, prioritize offline replication, add identity/feeds, and choose different flagship workflows (e.g., offline share and verify)."
}