{
  "id": 99,
  "title": "gui_tkinter_phase2_3_prefs",
  "body": "import os\nimport threading\nimport tkinter as tk\nfrom tkinter import ttk, filedialog, simpledialog, messagebox\nfrom pathlib import Path\nfrom PIL import ImageTk, Image\nimport subprocess\nimport sys\nimport json\nimport re\nimport xml.etree.ElementTree as ET\n\n# FunKit modules\nfrom modules import hypertext_parser, image_generator, document_store\nfrom modules.renderer import render_binary_as_text\nfrom modules.logger import Logger\nfrom modules.directory_import import import_text_files_from_directory\nfrom modules.TreeView import open_tree_view\n\n\n# --- OPML Engine (case-safe import) ---\ntry:\n    from modules.aopmlengine import build_opml_from_text, build_opml_from_html, EngineConfig  # type: ignore\nexcept Exception:\n    try:\n        from modules.aopmlengine import build_opml_from_text, build_opml_from_html, EngineConfig  # type: ignore\n    except Exception:\n        try:\n            from aopmlengine import build_opml_from_text, build_opml_from_html, EngineConfig  # type: ignore\n        except Exception:\n            try:\n                from aopmlengine import build_opml_from_text, build_opml_from_html, EngineConfig  # type: ignore\n            except Exception:\n                build_opml_from_text = build_opml_from_html = EngineConfig = None  # type: ignore\n\nimport re as _re_phase1\n_HTML_SIGNS = _re_phase1.compile(r\"<\\s*(!doctype|html|head|body|h[1-6]|p|div|ul|ol|li)\\b\", _re_phase1.I)\nSETTINGS_FILE = Path(\"funkit_settings.json\")\n\n\nclass DemoKitGUI(tk.Tk):\n    \"\"\"FunKit / DemoKit GUI with OPML auto-rendering in the document pane, TreeView integration, and utilities.\"\"\"\n\n    SIDEBAR_WIDTH = 320\n\n    def __init__(self, doc_store, processor):\n        super().__init__()\n        self.doc_store = doc_store\n        self.processor = processor\n        self.logger: Logger = getattr(processor, \"logger\", Logger())\n        self.current_doc_id: int | None = None\n        self.history: list[int] = []\n\n        # image state\n        self._last_pil_img: Image.Image | None = None\n        self._last_tk_img: ImageTk.PhotoImage | None = None\n        self._image_enlarged: bool = False\n\n        # ---- Settings ----\n        self.settings = self._load_settings()\n        self.opml_expand_depth: int = int(self.settings.get(\"opml_expand_depth\", 2))\n\n        self.title(\"Engelbart Journal \u2013 DemoKit \u2014 Phase 1 OPML \u2014 Phase 2 OPML (SAFE Batch) \u2014 Phase 2.2 (SAFE Batch + HTML Ingest) \u2014 Phase 2.3 (Prefs)\")\n        self.geometry(\"1200x800\")\n        self.columnconfigure(0, minsize=self.SIDEBAR_WIDTH, weight=0)\n        self.columnconfigure(1, weight=1)\n        self.rowconfigure(0, weight=1)\n\n        self._build_sidebar()\n        self._build_main_pane()\n        self._build_context_menu()\n\n        # --- Menubar ---\n        menubar = tk.Menu(self)\n        # File menu\n        filemenu = tk.Menu(menubar, tearoff=0)\n        filemenu.add_command(label=\"Import\", command=self._import_doc)\n        filemenu.add_command(label=\"Import HTML \u2192 OPML\", command=self._import_html_as_opml)\n        filemenu.add_command(label=\"Export Current\", command=self._export_doc)\n        filemenu.add_separator()\n        filemenu.add_command(label=\"Export to Intraweb\", command=self.export_and_launch_server)\n        filemenu.add_separator()\n        filemenu.add_command(label=\"Quit\", command=self.destroy)\n        menubar.add_cascade(label=\"File\", menu=filemenu)\n\n        # View menu (adds TreeView entry + shortcut + depth)\n        viewmenu = tk.Menu(menubar, tearoff=0)\n        viewmenu.add_command(label=\"Document Tree\\tCtrl+T\", command=self.on_tree_button)\n        viewmenu.add_separator()\n        viewmenu.add_command(label=\"Set OPML Expand Depth\u2026\", command=self._set_opml_expand_depth)\n        menubar.add_cascade(label=\"View\", menu=viewmenu)\n\n        self.config(menu=menubar)\n        # Keyboard shortcut\n        self.bind(\"<Control-t>\", lambda e: self.on_tree_button())\n\n        self._refresh_sidebar()\n\n    # ---------------- Settings ----------------\n\n    def _load_settings(self) -> dict:\n        try:\n            if SETTINGS_FILE.exists():\n                return json.loads(SETTINGS_FILE.read_text(encoding=\"utf-8\"))\n        except Exception:\n            pass\n        return {}\n\n    def _save_settings(self):\n        try:\n            SETTINGS_FILE.write_text(json.dumps(self.settings, indent=2), encoding=\"utf-8\")\n        except Exception as e:\n            print(\"[WARN] Could not save settings:\", e)\n\n    def _set_opml_expand_depth(self):\n        val = simpledialog.askinteger(\n            \"OPML Expand Depth\",\n            \"Expand OPML to depth (0=root, 1=children, 2=grandchildren\u2026):\",\n            initialvalue=self.opml_expand_depth,\n            minvalue=0,\n            maxvalue=99,\n        )\n        if val is None:\n            return\n        self.opml_expand_depth = int(val)\n        self.settings[\"opml_expand_depth\"] = self.opml_expand_depth\n        self._save_settings()\n        # If a Tree window with OPML loaded is open, apply immediately\n        win = getattr(self, \"tree_win\", None)\n        if win and win.winfo_exists():\n            self._apply_opml_expand_depth()\n\n    # ---------------- Sidebar ----------------\n\n    def _build_sidebar(self):\n        frame = tk.Frame(self)\n        frame.grid(row=0, column=0, sticky=\"nswe\")\n        self.sidebar = ttk.Treeview(frame, columns=(\"ID\", \"Title\", \"Description\"), show=\"headings\")\n        for col, w in ((\"ID\", 60), (\"Title\", 120), (\"Description\", 160)):\n            self.sidebar.heading(col, text=col)\n            self.sidebar.column(col, width=w, anchor=\"w\", stretch=(col == \"Description\"))\n        self.sidebar.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        ttk.Scrollbar(frame, orient=\"vertical\", command=self.sidebar.yview).pack(side=tk.RIGHT, fill=tk.Y)\n        self.sidebar.bind(\"<<TreeviewSelect>>\", self._on_select)\n        self.sidebar.bind(\"<Delete>\", lambda e: self._on_delete_clicked())\n\n    def _refresh_sidebar(self):\n        self.sidebar.delete(*self.sidebar.get_children())\n        for doc in self.doc_store.get_document_index():\n            self.sidebar.insert(\"\", \"end\", values=(doc[\"id\"], doc[\"title\"], doc[\"description\"]))\n\n    def _on_select(self, event):\n        sel = self.sidebar.selection()\n        if not sel:\n            return\n        item = self.sidebar.item(sel[0])\n        try:\n            nid = int(item[\"values\"][0])\n        except (ValueError, TypeError):\n            return\n        if self.current_doc_id is not None:\n            self.history.append(self.current_doc_id)\n        self.current_doc_id = nid\n        doc = self.doc_store.get_document(nid)\n        if doc:\n            self._render_document(doc)\n\n    # ---------------- Main Pane ----------------\n\n    def _build_main_pane(self):\n        pane = tk.Frame(self)\n        pane.grid(row=0, column=1, sticky=\"nswe\", padx=4, pady=4)\n        pane.rowconfigure(0, weight=3)\n        pane.rowconfigure(1, weight=1)\n        pane.columnconfigure(0, weight=1)\n\n        self.text = tk.Text(pane, wrap=\"word\")\n        self.text.grid(row=0, column=0, sticky=\"nswe\")\n        self.text.tag_configure(\"link\", foreground=\"green\", underline=True)\n        self.text.bind(\"<Button-3>\", self._show_context_menu)\n        self.text.bind(\"<Delete>\", lambda e: self._on_delete_clicked())\n\n        self.img_label = tk.Label(pane)\n        self.img_label.grid(row=1, column=0, sticky=\"ew\", pady=(8, 0))\n        self.img_label.bind(\"<Button-1>\", lambda e: self._toggle_image())\n\n        btns = tk.Frame(pane)\n        btns.grid(row=2, column=0, sticky=\"we\", pady=(6, 0))\n        acts = [\n            (\"TREE\", self.on_tree_button),\n            (\"OPEN OPML\", self._open_opml_from_main),\n            (\"ASK\", self._handle_ask),\n            (\"BACK\", self._go_back),\n            (\"DELETE\", self._on_delete_clicked),\n            (\"IMAGE\", self._handle_image),\n            (\"FLASK\", self.export_and_launch_server),\n            (\"DIR IMPORT\", self._import_directory),\n            (\"SAVE AS TEXT\", self._save_binary_as_text),\n                    (\"Convert to OPML\", self._convert_current_to_opml),\n            (\"Batch: Create OPML copies\", self._batch_create_opml_copies),\n]\n        for i, (lbl, cmd) in enumerate(acts):\n            ttk.Button(btns, text=lbl, command=cmd).grid(row=0, column=i, sticky=\"we\", padx=(0, 4))\n\n    # ---------------- Context Menu ----------------\n\n    def _build_context_menu(self):\n        self.context_menu = tk.Menu(self, tearoff=0)\n        self.context_menu.add_command(label=\"ASK\", command=self._handle_ask)\n        self.context_menu.add_command(label=\"Delete\", command=self._on_delete_clicked)\n        self.context_menu.add_separator()\n        self.context_menu.add_command(label=\"Import\", command=self._import_doc)\n        self.context_menu.add_command(label=\"Export\", command=self._export_doc)\n        self.context_menu.add_command(label=\"Save Binary As Text\", command=self._save_binary_as_text)\n\n    def _show_context_menu(self, event):\n        try:\n            self.context_menu.tk_popup(event.x_root, event.y_root)\n        finally:\n            self.context_menu.grab_release()\n\n    # ---------------- ASK / BACK ----------------\n\n    def _handle_ask(self):\n        try:\n            start = self.text.index(tk.SEL_FIRST)\n            end = self.text.index(tk.SEL_LAST)\n            selected_text = self.text.get(start, end)\n        except tk.TclError:\n            messagebox.showwarning(\"ASK\", \"Please select some text first.\")\n            return\n\n        cid = self.current_doc_id\n\n        def on_success(nid):\n            messagebox.showinfo(\"ASK\", f\"Created new document {nid}.\")\n            self._refresh_sidebar()\n            # replace selection with link\n            self.text.delete(start, end)\n            link_md = f\"[{selected_text}](doc:{nid})\"\n            self.text.insert(start, link_md)\n            full = self.text.get(\"1.0\", tk.END)\n            doc = self.doc_store.get_document(nid)\n            if isinstance(doc[\"body\"], bytes):\n                self.text.insert(tk.END, \"[binary document]\")\n                return\n            hypertext_parser.parse_links(self.text, full, self._on_link_click)\n\n        prefix = simpledialog.askstring(\"Prefix\", \"Optional prefix:\", initialvalue=\"Please expand:\")\n        self.processor.query_ai(\n            selected_text, cid, on_success, lambda *_: None, prefix=prefix, sel_start=None, sel_end=None\n        )\n\n    def _go_back(self):\n        if not self.history:\n            messagebox.showinfo(\"BACK\", \"No history.\")\n            return\n        prev = self.history.pop()\n        self.current_doc_id = prev\n        doc = self.doc_store.get_document(prev)\n        if doc:\n            self._render_document(doc)\n        else:\n            messagebox.showerror(\"BACK\", f\"Document {prev} not found.\")\n\n    # ---------------- TreeView wiring ----------------\n\n    def on_tree_button(self):\n        \"\"\"Open the TreeView window using the current document as the root (if any).\"\"\"\n\n        class _DocStoreRepo:\n            \"\"\"Adapter that derives parent\u2192children from green links like (doc:123).\"\"\"\n\n            def __init__(self, ds):\n                self.ds = ds\n                self._roots_cache = None\n\n            def _mk_node(self, d):\n                if not d:\n                    return None\n                if isinstance(d, dict):\n                    return type(\n                        \"DocNodeShim\",\n                        (object,),\n                        {\n                            \"id\": d.get(\"id\"),\n                            \"title\": d.get(\"title\") or \"(untitled)\",\n                            \"parent_id\": d.get(\"parent_id\"),\n                        },\n                    )()\n                did = d[0] if len(d) > 0 else None\n                title = d[1] if len(d) > 1 else \"\"\n                return type(\"DocNodeShim\", (object,), {\"id\": did, \"title\": title or \"(untitled)\", \"parent_id\": None})()\n\n            def get_doc(self, doc_id: int):\n                return self._mk_node(self.ds.get_document(doc_id))\n\n            def _body(self, doc):\n                return doc[\"body\"] if isinstance(doc, dict) else (doc[2] if len(doc) > 2 else \"\")\n\n            def _children_from_links(self, parent_id):\n                d = self.ds.get_document(parent_id)\n                if not d:\n                    return []\n                body = self._body(d)\n                if isinstance(body, (bytes, bytearray)):\n                    return []\n                ids = [int(m) for m in re.findall(r\"\\(doc:(\\d+)\\)\", body)]\n                out = []\n                for cid in ids:\n                    nd = self.ds.get_document(cid)\n                    if nd:\n                        out.append(self._mk_node(nd))\n                out.sort(key=lambda n: n.id)\n                return out\n\n            def get_children(self, parent_id):\n                # No parent_id column in the DB, so derive from green-link references\n                if parent_id is None:\n                    if self._roots_cache is None:\n                        all_ids = [row[\"id\"] for row in self.ds.get_document_index()]\n                        referenced = set()\n                        for row in self.ds.get_document_index():\n                            d = self.ds.get_document(row[\"id\"])\n                            body = self._body(d)\n                            if isinstance(body, (bytes, bytearray)):\n                                continue\n                            referenced.update(int(m) for m in re.findall(r\"\\(doc:(\\d+)\\)\", body))\n                        # roots = docs never referenced by any other doc\n                        roots = [self._mk_node(self.ds.get_document(i)) for i in all_ids if i not in referenced]\n                        if not roots:  # fallback: show all if everything is referenced\n                            roots = [self._mk_node(self.ds.get_document(i)) for i in all_ids]\n                        self._roots_cache = [n for n in roots if n]\n                        self._roots_cache.sort(key=lambda n: n.id)\n                    return list(self._roots_cache)\n                else:\n                    return self._children_from_links(parent_id)\n\n        repo = _DocStoreRepo(self.doc_store)\n        root_id = self.current_doc_id\n        self.tree_win = open_tree_view(self, repo=repo, on_open_doc=self._on_link_click, root_doc_id=root_id)\n\n    def _apply_opml_expand_depth(self):\n        \"\"\"Expand OPML tree in TreeView window to preferred depth.\"\"\"\n        win = getattr(self, \"tree_win\", None)\n        if not win or not win.winfo_exists():\n            return\n        if hasattr(win, \"_expand_to_depth\"):\n            win._expand_to_depth(self.opml_expand_depth)\n            return\n        tree = getattr(win, \"tree\", None)\n        if not tree:\n            return\n\n        def walk(iid: str, depth: int):\n            if depth >= self.opml_expand_depth:\n                return\n            win.tree.item(iid, open=True)\n            for c in win.tree.get_children(iid):\n                walk(c, depth + 1)\n\n        for top in tree.get_children(\"\"):\n            walk(top, 0)\n        if hasattr(win, \"_update_numbering\"):\n            win._update_numbering()\n\n    # ---- OPML-in-document-pane helpers ----\n\n    def _ensure_opml_widgets(self):\n        \"\"\"Create (or reuse) the OPML widgets embedded in the document pane.\"\"\"\n        if hasattr(self, \"_opml_frame\") and self._opml_frame.winfo_exists():\n            return\n        pane = self.text.master  # the grid container created in _build_main_pane\n        self._opml_frame = tk.Frame(pane)\n        self._opml_frame.grid(row=0, column=0, sticky=\"nswe\")\n        # Toolbar for OPML mode\n        tb = tk.Frame(self._opml_frame)\n        tb.pack(side=tk.TOP, fill=tk.X)\n        self._opml_show_nums = tk.BooleanVar(value=True)\n        ttk.Checkbutton(tb, text=\"Show Numbers\", variable=self._opml_show_nums, command=self._opml_update_numbering).pack(\n            side=tk.LEFT, padx=6\n        )\n        # Treeview for OPML\n        self._opml_tree = ttk.Treeview(self._opml_frame, columns=(\"num\",), show=\"tree headings\")\n        self._opml_tree.heading(\"num\", text=\"No.\")\n        self._opml_tree.column(\"num\", width=90, minwidth=60, stretch=False, anchor=\"e\")\n        vsb = ttk.Scrollbar(self._opml_frame, orient=\"vertical\", command=self._opml_tree.yview)\n        hsb = ttk.Scrollbar(self._opml_frame, orient=\"horizontal\", command=self._opml_tree.xview)\n        self._opml_tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)\n        self._opml_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        vsb.pack(side=tk.RIGHT, fill=tk.Y)\n        hsb.pack(side=tk.BOTTOM, fill=tk.X)\n\n    def _show_opml(self):\n        self._ensure_opml_widgets()\n        # Hide text view (uses grid)\n        if self.text.winfo_manager():\n            self.text.grid_remove()\n        self._hide_image()\n        self._opml_frame.lift()\n        self._opml_frame.grid()\n\n    def _hide_opml(self):\n        if hasattr(self, \"_opml_frame\") and self._opml_frame.winfo_exists():\n            self._opml_frame.grid_remove()\n        # Restore text\n        if not self.text.winfo_manager():\n            self.text.grid(row=0, column=0, sticky=\"nswe\")\n\n    def _render_opml_from_string(self, s: str):\n        \"\"\"Parse OPML XML from a string and render it into the embedded tree.\"\"\"\n        try:\n            if isinstance(s, (bytes, bytearray)):\n                s = s.decode(\"utf-8\", errors=\"replace\")\n            s = s.lstrip(\"\\ufeff\\r\\n\\t \")  # strip BOM/whitespace\n            root = ET.fromstring(s)\n        except Exception as e:\n            print(\"[WARN] OPML parse failed:\", e)\n            # Fall back to text view\n            self._hide_opml()\n            self.text.delete(\"1.0\", tk.END)\n            self.text.insert(tk.END, s or \"\")\n            return\n        if root.tag.lower() != \"opml\":\n            self._hide_opml()\n            self.text.delete(\"1.0\", tk.END)\n            self.text.insert(tk.END, s or \"\")\n            return\n\n        # It's OPML; render\n        self._show_opml()\n        # Clear previous content\n        for iid in self._opml_tree.get_children(\"\"):\n            self._opml_tree.delete(iid)\n        # Find <body> and its <outline> children\n        body = None\n        for child in root:\n            if child.tag.lower().endswith(\"body\"):\n                body = child\n                break\n        outlines = body.findall(\"outline\") if body is not None else list(root)\n\n        def insert_elem(parent_iid, elem):\n            text = (\n                elem.attrib.get(\"text\")\n                or elem.attrib.get(\"title\")\n                or (elem.text.strip() if elem.text else \"\")\n                or \"[No Text]\"\n            )\n            iid = self._opml_tree.insert(parent_iid, \"end\", text=text)\n            for c in elem:\n                if c.tag.lower() in {\"outline\", \"node\", \"item\"}:\n                    insert_elem(iid, c)\n\n        for e in outlines:\n            if e.tag.lower() in {\"outline\", \"node\", \"item\"}:\n                insert_elem(\"\", e)\n\n        # Auto-expand and number\n        self._opml_expand_to_depth_in_pane(self.opml_expand_depth)\n        self._opml_update_numbering()\n\n    def _opml_expand_to_depth_in_pane(self, depth: int):\n        if not hasattr(self, \"_opml_tree\"):\n            return\n\n        def walk(iid, d):\n            if d >= depth:\n                return\n            self._opml_tree.item(iid, open=True)\n            for c in self._opml_tree.get_children(iid):\n                walk(c, d + 1)\n\n        for top in self._opml_tree.get_children(\"\"):\n            walk(top, 0)\n\n    def _opml_update_numbering(self):\n        if not hasattr(self, \"_opml_tree\"):\n            return\n        show = bool(self._opml_show_nums.get())\n        if show:\n            self._opml_tree.column(\"num\", width=90, minwidth=60, stretch=False, anchor=\"e\")\n        else:\n            self._opml_tree.column(\"num\", width=0, minwidth=0, stretch=False)\n            def clear(iid=\"\"):\n                for c in self._opml_tree.get_children(iid):\n                    self._opml_tree.set(c, \"num\", \"\")\n                    clear(c)\n            clear()\n            return\n\n        def renumber(iid=\"\", prefix=None):\n            if prefix is None:\n                prefix = []\n            kids = self._opml_tree.get_children(iid)\n            for idx, c in enumerate(kids, start=1):\n                parts = prefix + [idx]\n                self._opml_tree.set(c, \"num\", \".\".join(str(n) for n in parts))\n                renumber(c, parts)\n\n        renumber(\"\")\n\n    # ---------------- Image ops ----------------\n\n    def _looks_like_image(self, title: str) -> bool:\n        return title.lower().endswith((\".png\", \".jpg\", \".jpeg\", \".gif\", \".bmp\"))\n\n    def _show_image_bytes(self, raw: bytes):\n        from io import BytesIO\n        pil = Image.open(BytesIO(raw))\n        # Size to window-ish\n        w, h = max(100, self.winfo_width() - 40), max(100, self.winfo_height() - 40)\n        pil.thumbnail((w, h))\n        self._last_pil_img = pil\n        self._last_tk_img = ImageTk.PhotoImage(pil)\n        self.img_label.configure(image=self._last_tk_img)\n\n    def _hide_image(self):\n        if self.img_label and self.img_label.winfo_manager():\n            self.img_label.configure(image=\"\")\n\n    def _toggle_image(self):\n        if not self._last_pil_img:\n            return\n        if not self._image_enlarged:\n            win = tk.Toplevel(self)\n            win.title(\"Image Preview\")\n            sw, sh = self.winfo_screenwidth(), self.winfo_screenheight()\n            iw, ih = self._last_pil_img.size\n            win.geometry(f\"{min(iw, sw)}x{min(ih, sh)}\")\n            canvas = tk.Canvas(win)\n            hbar = ttk.Scrollbar(win, orient=\"horizontal\", command=canvas.xview)\n            vbar = ttk.Scrollbar(win, orient=\"vertical\", command=canvas.yview)\n            canvas.configure(xscrollcommand=hbar.set, yscrollcommand=vbar.set, scrollregion=(0, 0, iw, ih))\n            canvas.grid(row=0, column=0, sticky=\"nsew\")\n            hbar.grid(row=1, column=0, sticky=\"we\")\n            vbar.grid(row=0, column=1, sticky=\"ns\")\n            win.grid_rowconfigure(0, weight=1)\n            win.grid_columnconfigure(0, weight=1)\n            tk_img = ImageTk.PhotoImage(self._last_pil_img)\n            canvas.create_image(0, 0, anchor=\"nw\", image=tk_img)\n            canvas.image = tk_img\n            win.bind(\"<Button-1>\", lambda e: self._toggle_image())\n            self._image_enlarged = True\n        else:\n            default = f\"document_{self.current_doc_id}.png\"\n            path = filedialog.asksaveasfilename(\n                title=\"Save Image\",\n                initialfile=default,\n                defaultextension=\".png\",\n                filetypes=[(\"PNG\", \"*.png\"), (\"All Files\", \"*.*\")],\n            )\n            if path:\n                try:\n                    self._last_pil_img.save(path)\n                    messagebox.showinfo(\"Save Image\", f\"Image saved to:\\n{path}\")\n                except Exception as e:\n                    messagebox.showerror(\"Save Image\", f\"Error saving image:{e}\")\n            self._image_enlarged = False\n\n    def _handle_image(self):\n        try:\n            start = self.text.index(tk.SEL_FIRST)\n            end = self.text.index(tk.SEL_LAST)\n            prompt = self.text.get(start, end).strip()\n        except tk.TclError:\n            messagebox.showwarning(\"IMAGE\", \"Please select some text first.\")\n            return\n\n        def wrk():\n            try:\n                pil = image_generator.generate_image(prompt)\n                self._last_pil_img = pil\n                thumb = pil.copy()\n                thumb.thumbnail((800, 400))\n                self._last_tk_img = ImageTk.PhotoImage(thumb)\n                self._image_enlarged = False\n                self.after(0, lambda: self.img_label.configure(image=self._last_tk_img))\n            except Exception as e:\n                self.after(0, lambda: messagebox.showerror(\"Image Error\", str(e)))\n\n        threading.Thread(target=wrk, daemon=True).start()\n\n    # ---------------- Import/Export ----------------\n\n    # ---------------- Convert to OPML (Phase 1, safe) ----------------\n    def _convert_current_to_opml(self):\n        \"\"\"Create a new OPML document from the selection (or entire doc) without altering the original.\"\"\"\n        try:\n            if EngineConfig is None:\n                messagebox.showerror(\"OPML\", \"aopmlengine.py not found or failed to import.\")\n                return\n        except NameError:\n            messagebox.showerror(\"OPML\", \"aopmlengine import not available.\")\n            return\n\n        if getattr(self, \"current_doc_id\", None) is None:\n            messagebox.showwarning(\"OPML\", \"No document selected.\")\n            return\n\n        # Gather source text\n        full_text = self.text.get(\"1.0\", \"end-1c\")\n        try:\n            sel_start = self.text.index(tk.SEL_FIRST)\n            sel_end = self.text.index(tk.SEL_LAST)\n            src_txt = self.text.get(sel_start, sel_end)\n        except tk.TclError:\n            src_txt = full_text\n\n        if not (src_txt or \"\").strip():\n            messagebox.showwarning(\"OPML\", \"Nothing to convert.\")\n            return\n\n        try:\n            cur = self.doc_store.get_document(self.current_doc_id)\n            cur_title = (cur[\"title\"] if isinstance(cur, dict) else (cur[1] if cur else None)) or \"Document\"\n            opml_title = f\"{cur_title} (OPML)\"\n            cfg = EngineConfig(enable_ai=False, title=opml_title, owner_name=None)\n            opml_doc = build_opml_from_html(src_txt, cfg) if _HTML_SIGNS.search(src_txt) else build_opml_from_text(src_txt, cfg)\n            new_id = self.doc_store.add_document(opml_title, opml_doc.to_xml())\n            self._refresh_sidebar()\n            # Auto-open the OPML doc\n            self._on_link_click(new_id)\n            messagebox.showinfo(\"OPML\", f\"Created OPML document #{new_id}.\")\n        except Exception as e:\n            messagebox.showerror(\"OPML\", f\"Convert failed: {e}\")\n\n    # ---------------- Batch: Create OPML copies (SAFE, no edits to originals) ----------------\n    def _get_selected_ids_from_sidebar(self) -> list[int]:\n        ids: list[int] = []\n        for iid in self.sidebar.selection():\n            vals = self.sidebar.item(iid, \"values\") or []\n            if not vals:\n                continue\n            try:\n                ids.append(int(vals[0]))\n            except Exception:\n                pass\n        return ids\n\n    def _batch_create_opml_copies(self):\n        \"\"\"Create OPML siblings for all selected docs. Originals are left untouched.\"\"\"\n        try:\n            if EngineConfig is None:\n                messagebox.showerror(\"Batch OPML\", \"aopmlengine.py not found or failed to import.\")\n                return\n        except NameError:\n            messagebox.showerror(\"Batch OPML\", \"aopmlengine import not available.\")\n            return\n\n        ids = self._get_selected_ids_from_sidebar()\n        if not ids:\n            messagebox.showwarning(\"Batch OPML\", \"No documents selected.\")\n            return\n\n        created = []\n        failed = []\n\n        # Busy cursor\n        try:\n            self.config(cursor=\"watch\"); self.update_idletasks()\n        except Exception:\n            pass\n\n        for did in ids:\n            try:\n                row = self.doc_store.get_document(did)\n                if not row:\n                    raise RuntimeError(\"Not found\")\n                # title/body from dict or tuple\n                title = row[\"title\"] if isinstance(row, dict) else (row[1] if len(row) > 1 else \"Document\")\n                body = row[\"body\"] if isinstance(row, dict) else (row[2] if len(row) > 2 else \"\")\n                if isinstance(body, (bytes, bytearray)):\n                    raise RuntimeError(\"Binary document not supported\")\n\n                opml_title = f\"{title or 'Document'} (OPML)\"\n                cfg = EngineConfig(enable_ai=False, title=opml_title, owner_name=None)\n                opml_doc = build_opml_from_html(body or \"\", cfg) if _HTML_SIGNS.search(body or \"\") else build_opml_from_text(body or \"\", cfg)\n                new_id = self.doc_store.add_document(opml_title, opml_doc.to_xml())\n                created.append((did, new_id, opml_title))\n            except Exception as e:\n                failed.append((did, str(e)))\n\n        try:\n            self.config(cursor=\"\")\n        except Exception:\n            pass\n\n        self._refresh_sidebar()\n\n        # Report\n        if created:\n            first_new_id = created[0][1]\n            # Optionally open the first created OPML doc\n            try:\n                self._on_link_click(first_new_id)\n            except Exception:\n                pass\n\n        if failed:\n            msg = \"; \".join(f\"#{d}: {err}\" for d, err in failed[:5])\n            extra = \" (showing first 5)\" if len(failed) > 5 else \"\"\n            messagebox.showwarning(\"Batch OPML\", f\"Created {len(created)} OPML doc(s), {len(failed)} failed{extra}: {msg}\")\n        else:\n            messagebox.showinfo(\"Batch OPML\", f\"Created {len(created)} OPML doc(s). Originals were not modified.\")\n\n    def _import_html_as_opml(self):\n        \"\"\"Pick an .html/.htm file and import it directly as OPML (new doc).\"\"\"\n        from pathlib import Path\n        if EngineConfig is None:\n            messagebox.showerror(\"Import HTML \u2192 OPML\", \"aopmlengine.py not found or failed to import.\")\n            return\n        path = filedialog.askopenfilename(\n            title=\"Import HTML \u2192 OPML\",\n            filetypes=[(\"HTML\", \"*.html *.htm\"), (\"All files\", \"*.*\")],\n        )\n        if not path:\n            return\n        p = Path(path)\n        try:\n            html = p.read_text(encoding=\"utf-8\", errors=\"replace\")\n        except Exception as e:\n            messagebox.showerror(\"Import HTML \u2192 OPML\", f\"Failed to read file: {e}\")\n            return\n        try:\n            title = p.stem\n            cfg = EngineConfig(enable_ai=False, title=f\"{title} (OPML)\", owner_name=None)\n            opml_doc = build_opml_from_html(html, cfg)\n            new_id = self.doc_store.add_document(f\"{title} (OPML)\", opml_doc.to_xml())\n        except Exception as e:\n            messagebox.showerror(\"Import HTML \u2192 OPML\", f\"Failed to convert: {e}\")\n            return\n        self._refresh_sidebar()\n        self.current_doc_id = new_id\n        doc = self.doc_store.get_document(new_id)\n        if doc:\n            self._render_document(doc)\n        messagebox.showinfo(\"Import HTML \u2192 OPML\", f\"Imported as OPML document #{new_id}.\")\n\n    def _import_doc(self):\n        path = filedialog.askopenfilename(title=\"Import\", filetypes=[(\"Text\", \"*.txt\"), (\"All\", \"*.*\")])\n        if not path:\n            return\n        body = Path(path).read_text(encoding=\"utf-8\")\n        title = Path(path).stem\n        nid = self.doc_store.add_document(title, body)\n        self.logger.info(f\"Imported {nid}\")\n        self._refresh_sidebar()\n        doc = self.doc_store.get_document(nid)\n        if doc:\n            self._render_document(doc)\n\n    def _export_doc(self):\n        if self.current_doc_id is None:\n            messagebox.showwarning(\"Export\", \"No document loaded.\")\n            return\n        doc = self.doc_store.get_document(self.current_doc_id)\n        if not doc:\n            messagebox.showerror(\"Export\", \"Not found.\")\n            return\n        default = f\"document_{self.current_doc_id}.txt\"\n        path = filedialog.asksaveasfilename(\n            title=\"Export\", initialfile=default, defaultextension=\".txt\", filetypes=[(\"Text\", \"*.txt\"), (\"All\", \"*.*\")]\n        )\n        if not path:\n            return\n        Path(path).write_text(doc[\"body\"], encoding=\"utf-8\")\n        messagebox.showinfo(\"Export\", f\"Saved to:\\n{path}\")\n\n    def _import_directory(self):\n        dir_path = filedialog.askdirectory(title=\"Select Folder to Import\")\n        if not dir_path:\n            return\n        imported, skipped = import_text_files_from_directory(dir_path, self.doc_store)\n        msg = f\"Imported {imported} file(s), skipped {skipped}.\"\n        print(\"[INFO]\", msg)\n        messagebox.showinfo(\"Directory Import\", msg)\n        self._refresh_sidebar()\n\n    def export_and_launch_server(self):\n        export_path = Path(\"exported_docs\")\n        export_path.mkdir(exist_ok=True)\n        for doc in self.doc_store.get_document_index():\n            data = dict(self.doc_store.get_document(doc[\"id\"]))\n            if data:\n                data = sanitize_doc(data)\n                with open(export_path / f\"{data['id']}.json\", \"w\", encoding=\"utf-8\") as f:\n                    json.dump(data, f, indent=2)\n\n        def launch():\n            fp = Path(\"modules\") / \"flask_server.py\"\n            if fp.exists():\n                subprocess.Popen([sys.executable, str(fp)])\n\n        threading.Thread(target=launch, daemon=True).start()\n        messagebox.showinfo(\"Server Started\", \"Flask server launched at http://127.0.0.1:5050\")\n\n    def _save_binary_as_text(self):\n        selected_item = self.sidebar.selection()\n        if not selected_item:\n            return\n        doc_id_str = self.sidebar.item(selected_item, \"values\")[0]\n        if not str(doc_id_str).isdigit():\n            print(f\"Warning: selected text is not a valid integer '{doc_id_str}'\")\n            return\n        doc_id = int(doc_id_str)\n        doc = self.doc_store.get_document(doc_id)\n        if not doc or len(doc) < 3:\n            return\n        body = doc[2]\n        if isinstance(body, bytes) or (\"\\x00\" in str(body)):\n            print(\"Binary detected, converting to text using render_binary_as_text.\")\n            body = render_binary_as_text(body)\n            self.doc_store.update_document(doc_id, body)\n            self._render_document(self.doc_store.get_document(doc_id))\n        else:\n            print(\"Document is already text. Skipping overwrite.\")\n        content = self.processor.get_strings_content(doc_id)\n        self.doc_store.update_document(doc_id, content)\n        doc = self.doc_store.get_document(doc_id)\n        self._render_document(doc)\n\n    # ---------------- Open OPML (import) ----------------\n\n    def _open_opml_from_main(self):\n        path = filedialog.askopenfilename(\n            title=\"Open OPML/XML\", filetypes=[(\"OPML / XML\", \"*.opml *.xml\"), (\"All files\", \"*.*\")]\n        )\n        if not path:\n            return\n        try:\n            content = Path(path).read_text(encoding=\"utf-8\", errors=\"replace\")\n        except Exception as e:\n            messagebox.showerror(\"Open OPML\", f\"Failed to read file:\\n{e}\")\n            return\n        title = Path(path).stem\n        try:\n            new_id = self.doc_store.add_document(title, content)\n        except Exception as e:\n            messagebox.showerror(\"Open OPML\", f\"Failed to import OPML to DB:\\n{e}\")\n            return\n        self._refresh_sidebar()\n        self.current_doc_id = new_id\n        doc = self.doc_store.get_document(new_id)\n        if doc:\n            self._render_document(doc)\n        if getattr(self, \"tree_win\", None) and self.tree_win.winfo_exists():\n            try:\n                self.tree_win.load_opml_file(path)\n                self.tree_win.deiconify()\n                self.tree_win.lift()\n                self._apply_opml_expand_depth()\n            except Exception:\n                pass\n\n    # ---------------- Rendering ----------------\n\n    def _render_document(self, doc):\n        \"\"\"Render a document once, parse green links, and auto-render OPML when detected.\"\"\"\n        # Normalize doc body\n        body = doc.get(\"body\") if isinstance(doc, dict) else (doc[2] if len(doc) > 2 else \"\")\n        if isinstance(body, str):\n            b_norm = body.lstrip(\"\\ufeff\\r\\n\\t \")\n            if \"<opml\" in b_norm.lower():\n                self._render_opml_from_string(b_norm)\n                return\n\n        # Plain text or other\n        self._hide_opml()\n        self.text.delete(\"1.0\", tk.END)\n\n        # bytes -> placeholder\n        if isinstance(body, (bytes, bytearray)):\n            self.text.insert(tk.END, \"[binary document]\")\n            return\n\n        # very large text -> placeholder\n        if isinstance(body, str) and len(body) > 200_000:\n            self.text.insert(tk.END, \"[large binary-like document]\")\n            return\n\n        # Show and parse links\n        self.text.insert(tk.END, body or \"\")\n        hypertext_parser.parse_links(self.text, body or \"\", self._on_link_click)\n\n    def _on_link_click(self, doc_id):\n        if self.current_doc_id is not None:\n            self.history.append(self.current_doc_id)\n        self.current_doc_id = doc_id\n        doc = self.doc_store.get_document(doc_id)\n        if doc:\n            self._render_document(doc)\n\n\n    def _on_delete_clicked(self):\n        \"\"\"Delete the currently selected document from the sidebar and clear the pane.\"\"\"\n        sel = self.sidebar.selection()\n        if not sel:\n            messagebox.showwarning(\"Delete\", \"No document selected.\")\n            return\n        item = self.sidebar.item(sel[0])\n        vals = item.get(\"values\") or []\n        if not vals:\n            messagebox.showerror(\"Delete\", \"Invalid selection.\")\n            return\n        try:\n            nid = int(vals[0])\n        except (ValueError, TypeError):\n            messagebox.showerror(\"Delete\", \"Invalid document ID.\")\n            return\n        if not messagebox.askyesno(\"Confirm Delete\", f\"Delete document ID {nid}?\"):\n            return\n        try:\n            self.doc_store.delete_document(nid)\n        except Exception as e:\n            messagebox.showerror(\"Delete\", f\"Failed to delete: {e}\")\n            return\n        # Clear UI\n        self._refresh_sidebar()\n        self.text.delete(\"1.0\", tk.END)\n        if hasattr(self, \"_opml_frame\") and self._opml_frame.winfo_exists():\n            self._opml_frame.grid_remove()\n        if hasattr(self, \"img_label\"):\n            self.img_label.configure(image=\"\")\n        self.current_doc_id = None\n        self._last_pil_img = None\n        self._last_tk_img = None\n        self._image_enlarged = False\n        messagebox.showinfo(\"Deleted\", f\"Document {nid} has been deleted.\")\n\ndef sanitize_doc(doc):\n    if isinstance(doc[\"body\"], bytes):\n        try:\n            doc[\"body\"] = doc[\"body\"].decode(\"utf-8\")\n        except UnicodeDecodeError:\n            doc[\"body\"] = doc[\"body\"].decode(\"utf-8\", errors=\"replace\")\n    return doc\n"
}