{
  "id": 27,
  "title": "Pikit_Build_Deluxe_Script",
  "body": "#!/bin/bash\n# =============================================================================\n# FunKit Snapshot Build Script \u2014 Heavily Commented Edition\n#\n# Document summary\n# - Purpose:\n#   Creates a timestamped, self-contained snapshot build (PyInstaller one-file)\n#   of the FunKit project and deposits the binary in $HOME/funkit-snapshots.\n#\n# - What it does (high level):\n#   1) Prepares a clean build workspace.\n#   2) Copies the project source into that workspace (excluding .git and __pycache__).\n#   3) Copies the current storage directory into the workspace.\n#   4) Creates a virtual environment and installs dependencies.\n#   5) Uses PyInstaller to produce a standalone binary from main.py.\n#   6) Moves the resulting binary to a snapshots directory with a timestamped name.\n#\n# - Primary outputs:\n#   $HOME/funkit-snapshots/funkit_snapshot_YYYY-MM-DD_HH-MM-SS.bin\n#\n# - Use cases:\n#   \u2022 Shareable snapshot for non-developers or testers without requiring Python installed.\n#   \u2022 Reproducible test builds for QA to capture a point-in-time state of the app.\n#   \u2022 CI/CD artifact generation for nightly or on-demand builds.\n#   \u2022 Demo or field distribution that can run on compatible target systems.\n#   \u2022 Quick backup of a working build, aligned with current requirements.txt.\n#\n# - Requirements on the system:\n#   \u2022 bash, rsync, python3 with venv module, pip, and internet connectivity (to install dependencies).\n#   \u2022 PyInstaller (installed by this script into the virtualenv).\n#   \u2022 A main.py entry point in the project root.\n#\n# - Notes and caveats:\n#   \u2022 This script uses `set -e` to stop immediately on the first error.\n#   \u2022 PyInstaller --onefile does NOT automatically include arbitrary folders.\n#     As written, copying \"storage\" into the build directory makes it available DURING build,\n#     but it is NOT embedded into the final one-file binary unless explicitly added via --add-data\n#     or a .spec file.\n#     If you need \"storage\" embedded in the binary, consider:\n#       pyinstaller main.py --onefile --clean --name \"$SNAPSHOT_NAME\" \\\n#         --add-data \"storage:storage\"\n#     Alternatively, use a one-folder build or ship the \"storage\" directory alongside the binary.\n#   \u2022 The output is renamed with a .bin extension for clarity; on Linux/macOS this is not required.\n#     On Windows, you'd want .exe instead and to build on Windows.\n#   \u2022 The script places the build directory (funkit_snapshot_build) inside the project root.\n#     rsync builds its file list before copying, so it typically avoids recursing into the target.\n#     Still, excluding the build dir explicitly is a common safety measure if you modify this script.\n#   \u2022 If the \"storage\" directory does not exist, the copy step will fail and the script will exit.\n#\n# - Portability:\n#   Targeted at Unix-like systems (Linux/macOS). For Windows, use PowerShell/CMD and\n#   a Windows Python environment to produce a native .exe.\n#\n# =============================================================================\n\n# Exit immediately if any command returns a non-zero status.\n# This prevents continuing after a failure (e.g., pip install error).\nset -e\n\n# Log: starting the snapshot build process (includes emojis for readability).\necho \"\ud83d\udce6 Starting FunKit Snapshot Build...\"\n\n# -----------------------------------------------------------------------------\n# Step 1: Define snapshot naming and directories, and prepare a clean workspace.\n# -----------------------------------------------------------------------------\n\n# SNAPSHOT_NAME is timestamped to make every run produce a unique build artifact.\nSNAPSHOT_NAME=\"funkit_snapshot_$(date +%Y-%m-%d_%H-%M-%S)\"\n\n# SNAPSHOT_DIR is where the final binary will be moved for safekeeping.\nSNAPSHOT_DIR=\"$HOME/funkit-snapshots\"\n\n# BUILD_DIR is the temporary build workspace created inside the project root.\n# Note: Keeping BUILD_DIR within the project root is convenient, but be mindful\n# of rsync behavior. It\u2019s generally fine because rsync compiles the file list first,\n# but consider excluding BUILD_DIR explicitly if you customize this script.\nBUILD_DIR=\"funkit_snapshot_build\"\n\n# Ensure the snapshots directory exists.\nmkdir -p \"$SNAPSHOT_DIR\"\n\n# Start fresh by removing any old build workspace, then recreate it.\nrm -rf \"$BUILD_DIR\"\nmkdir \"$BUILD_DIR\"\n\n# Copy project source into the build workspace.\n# -a: archive mode (preserves permissions, timestamps, symlinks)\n# -v: verbose output\n# --exclude='__pycache__': omit Python bytecode caches\n# --exclude='.git': omit Git metadata\n# Dot (.) means \"copy the current directory contents\".\n# Destination is the BUILD_DIR we just created.\necho \"\ud83d\udd01 Copying project source into $BUILD_DIR...\"\nrsync -av --exclude='__pycache__' --exclude='.git' . \"$BUILD_DIR/\"\n\n# Copy the current 'storage' folder into the build workspace as well.\n# NOTE: This makes 'storage' available during build and for one-folder builds,\n# but it will NOT be embedded in a PyInstaller --onefile binary unless you\n# add it via --add-data or a .spec file. See the summary notes above.\n# If 'storage' doesn't exist, this command will fail and the script will exit.\necho \"\ud83d\uddc2\ufe0f Copying current storage folder into snapshot build...\"\ncp -r storage \"$BUILD_DIR/\"\n\n# -----------------------------------------------------------------------------\n# Step 2: Enter the build directory and prepare an isolated Python environment.\n# -----------------------------------------------------------------------------\n\n# Move into the build workspace so all subsequent actions operate from there.\ncd \"$BUILD_DIR\"\n\n# Create a dedicated virtual environment to ensure a clean, reproducible build.\necho \"\ud83d\udc0d Creating virtualenv for isolated build...\"\npython3 -m venv snapshot-env\n\n# Activate the virtual environment so pip installs into it, not system-wide.\nsource snapshot-env/bin/activate\n\n# Install dependencies into the virtual environment.\necho \"\ud83d\udcda Installing dependencies...\"\npip install --upgrade pip\npip install -r requirements.txt\npip install pyinstaller\n\n# -----------------------------------------------------------------------------\n# Step 3: Build the standalone binary with PyInstaller.\n# -----------------------------------------------------------------------------\n\n# Build a single-file executable from main.py.\n# Flags:\n# --onefile: produce a single bundled executable\n# --clean:   clean PyInstaller cache and temporary files before building\n# --name:    set the output binary's base name to $SNAPSHOT_NAME\n# IMPORTANT: As written, this does NOT embed the 'storage' folder.\n# To embed it, add: --add-data \"storage:storage\"\necho \"\ud83d\udcc4 Building standalone FunKit binary with full storage included...\"\npyinstaller main.py --onefile --clean --name \"$SNAPSHOT_NAME\"\n\n# -----------------------------------------------------------------------------\n# Step 4: Move the artifact to the snapshots directory and finalize.\n# -----------------------------------------------------------------------------\n\n# Move the built binary from dist/ to $SNAPSHOT_DIR and append .bin for clarity.\n# On Unix-like systems, extensions are optional; this is a cosmetic choice.\necho \"\ud83d\udcc1 Moving final binary to $SNAPSHOT_DIR/\"\nmv \"dist/$SNAPSHOT_NAME\" \"$SNAPSHOT_DIR/$SNAPSHOT_NAME.bin\"\n\n# Announce completion and show the final path for convenience.\necho \"\u2705 Snapshot complete: $SNAPSHOT_DIR/$SNAPSHOT_NAME.bin\""
}