{
  "id": 92,
  "title": "gui_tkinter-new-works",
  "body": "from modules.memory_dialog import open_memory_dialog\nimport os\nimport re\nimport sys\nimport json\nimport threading\nimport subprocess\nimport tkinter as tk\nfrom tkinter import ttk, filedialog, simpledialog, messagebox\nfrom pathlib import Path\nimport xml.etree.ElementTree as ET\n\n# Optional image support (Pillow). If missing, image features will be disabled gracefully.\ntry:\n    from PIL import Image, ImageTk  # type: ignore\n\n    _HAVE_PIL = True\nexcept Exception:\n    _HAVE_PIL = False\n\n\n# ---- Optional project modules (guarded so GUI still launches if absent) ----\ndef _try_import(modpath, name=None, default=None):\n    try:\n        mod = __import__(modpath, fromlist=[\"*\"])\n        return getattr(mod, name, mod) if name else mod\n    except Exception:\n        return default\n\n\nhypertext_parser = _try_import(\"modules.hypertext_parser\")\nimage_generator = _try_import(\"modules.image_generator\")\nlogger_mod = _try_import(\"modules.logger\")\nrender_bin_as_text = _try_import(\"modules.renderer\", \"render_binary_as_text\")\ndir_importer = _try_import(\n    \"modules.directory_import\", \"import_text_files_from_directory\"\n)\ntree_view_mod = _try_import(\"modules.TreeView\", \"open_tree_view\")\n\n\n# Fallbacks\nclass _NullLogger:\n    def info(self, *a, **k):\n        print(\"[INFO]\", *a)\n\n    def error(self, *a, **k):\n        print(\"[ERROR]\", *a)\n\n\nLogger = getattr(logger_mod, \"Logger\", _NullLogger)\n\nSETTINGS_FILE = Path(\"funkit_settings.json\")\n\n\nclass DemoKitGUI(tk.Tk):\n\n    def _build_bottom_toolbar(self, parent):\n        \"\"\"Bottom button row + single search box (no middle toolbar).\"\"\"\n        from tkinter import ttk, StringVar\n\n        bar = ttk.Frame(parent)\n        bar.grid(row=2, column=0, sticky=\"ew\", pady=(6, 4))\n        for c in range(8):\n            bar.grid_columnconfigure(c, weight=1)\n            ttk.Button(bar, text=\"TREE\", command=self.on_tree_button).grid(\n                row=0, column=0, sticky=\"ew\", padx=3\n            )\n            ttk.Button(bar, text=\"OPEN OPML\", command=self._open_opml_from_main).grid(\n                row=0, column=1, sticky=\"ew\", padx=3\n            )\n            ttk.Button(bar, text=\"ASK\", command=self._on_ask).grid(\n                row=0, column=2, sticky=\"ew\", padx=3\n            )\n            ttk.Button(bar, text=\"BACK\", command=self._go_back).grid(\n                row=0, column=3, sticky=\"ew\", padx=3\n            )\n            ttk.Button(bar, text=\"DIR IMPORT\", command=self._import_directory).grid(\n                row=0, column=4, sticky=\"ew\", padx=3\n            )\n            ttk.Button(bar, text=\"EXPORT\", command=self._export_doc).grid(\n                row=0, column=5, sticky=\"ew\", padx=3\n            )\n            ttk.Label(bar, text=\"Search:\").grid(\n                row=0, column=6, sticky=\"e\", padx=(12, 4)\n            )\n            self._search_var = StringVar()\n            entry = ttk.Entry(bar, textvariable=self._search_var)\n            entry.grid(row=0, column=7, sticky=\"ew\", padx=(0, 3))\n            entry.bind(\"<Return>\", lambda e: self.filter_index(self._search_var.get()))\n            self._search_entry = entry\n            return bar\n\n    def _open_memory_dialog(self):\n        try:\n            open_memory_dialog(self)\n        except Exception as e:\n            try:\n                from tkinter import messagebox\n\n                messagebox.showerror(\"Memory\", f\"Could not open memory dialog:\\n{e}\")\n            except Exception:\n                print(\"[Memory] Could not open:\", e)\n\n    \"\"\"FunKit GUI with OPML rendering, search, and basic import/export utilities.\"\"\"\n\n    SIDEBAR_WIDTH = 320\n\n    def __init__(self, doc_store, processor):\n        super().__init__()\n        self.root = self  # keep compatibility with code that expects self.root\n        self.doc_store = doc_store\n        self.processor = processor\n        self.logger = getattr(processor, \"logger\", Logger())\n\n        self.current_doc_id = None\n        self.history = []\n        self._suppress_sidebar_select = False\n\n        # Settings\n        self.settings = self._load_settings()\n        self.opml_expand_depth = int(self.settings.get(\"opml_expand_depth\", 2))\n\n        self.title(\"Engelbart Journal \u2014 FunKit\")\n        geom = self.settings.get(\"geometry\")\n        try:\n            self.geometry(geom if geom else \"1200x800\")\n        except Exception:\n            self.geometry(\"1200x800\")\n\n        # Grid\n        self.columnconfigure(0, minsize=self.SIDEBAR_WIDTH, weight=0)\n        self.columnconfigure(1, weight=1)\n        self.rowconfigure(0, weight=1)\n\n        # UI\n        self._build_sidebar()\n        self._build_main_pane()\n        self._build_context_menu()\n        self._build_menus()\n\n        # Initial data\n        self.refresh_index()\n\n        # Close protocol\n        self.protocol(\"WM_DELETE_WINDOW\", self._on_close)\n\n    # ---------------- Settings ----------------\n    def _load_settings(self) -> dict:\n        defaults = {\n            \"geometry\": None,\n            \"opml_expand_depth\": 2,\n            \"sidebar_width\": self.SIDEBAR_WIDTH,\n            \"recent_docs\": [],\n            \"memory\": {},\n            \"theme\": \"light\",\n        }\n        try:\n            if SETTINGS_FILE.exists():\n                with SETTINGS_FILE.open(\"r\", encoding=\"utf-8\") as f:\n                    data = json.load(f)\n                if isinstance(data, dict):\n                    out = defaults.copy()\n                    out.update(data)\n                    return out\n        except Exception as e:\n            print(\"[settings] load failed:\", e)\n        return defaults\n\n    def _save_settings(self) -> None:\n        try:\n            data = dict(self.settings or {})\n            data[\"geometry\"] = self.geometry()\n            data[\"opml_expand_depth\"] = int(\n                getattr(self, \"opml_expand_depth\", data.get(\"opml_expand_depth\", 2))\n            )\n            data[\"sidebar_width\"] = getattr(\n                self, \"SIDEBAR_WIDTH\", data.get(\"sidebar_width\", 320)\n            )\n            with SETTINGS_FILE.open(\"w\", encoding=\"utf-8\") as f:\n                json.dump(data, f, indent=2)\n        except Exception as e:\n            print(\"[settings] save failed:\", e)\n\n    def _on_close(self):\n        try:\n            self._save_settings()\n        except Exception:\n            pass\n        self.destroy()\n\n    # ---------------- Menus & Toolbar ----------------\n    def _build_menus(self):\n        menubar = tk.Menu(self)\n\n        filemenu = tk.Menu(menubar, tearoff=0)\n        filemenu.add_command(label=\"Import\u2026\", command=self._import_doc)\n        filemenu.add_command(label=\"Export Current\u2026\", command=self._export_doc)\n        filemenu.add_separator()\n        filemenu.add_command(label=\"Memory\u2026\", command=self._open_memory_dialog)\n        filemenu.add_command(label=\"Quit\", command=self._on_close)\n        menubar.add_cascade(label=\"File\", menu=filemenu)\n\n        viewmenu = tk.Menu(menubar, tearoff=0)\n        viewmenu.add_command(\n            label=\"Document Tree\", command=self.on_tree_button, accelerator=\"Ctrl+T\"\n        )\n        viewmenu.add_command(\n            label=\"Set OPML Expand Depth\u2026\", command=self._set_opml_expand_depth\n        )\n        menubar.add_cascade(label=\"View\", menu=viewmenu)\n\n        self.config(menu=menubar)\n        self.bind(\"<Control-m>\", lambda e: (self._open_memory_dialog(), \"break\"))\n        self.bind(\"<Alt-Left>\", lambda e: (self._go_back(), \"break\"))\n        self.bind(\"<Control-t>\", lambda e: self.on_tree_button())\n\n    def _build_sidebar(self):\n        frame = tk.Frame(self)\n        frame.grid(row=0, column=0, sticky=\"nswe\")\n        self.sidebar = ttk.Treeview(\n            frame, columns=(\"ID\", \"Title\", \"Description\"), show=\"headings\"\n        )\n        for col, w in ((\"ID\", 70), (\"Title\", 180), (\"Description\", 220)):\n            self.sidebar.heading(col, text=col)\n            self.sidebar.column(\n                col, width=w, anchor=\"w\", stretch=(col == \"Description\")\n            )\n        self.sidebar.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        ttk.Scrollbar(frame, orient=\"vertical\", command=self.sidebar.yview).pack(\n            side=tk.RIGHT, fill=tk.Y\n        )\n        self.sidebar.bind(\"<<TreeviewSelect>>\", self._on_select)\n\n    def _build_main_pane(self):\n\n        # Remove any center/middle toolbar remnants\n        for attr in (\"mid_panel\", \"toolbar\"):\n            w = getattr(self, attr, None)\n            if w is not None:\n                try:\n                    w.destroy()\n                except Exception:\n                    pass\n                setattr(self, attr, None)\n\n        pane = tk.Frame(self)\n        pane.grid(row=0, column=1, sticky=\"nswe\", padx=4, pady=4)\n        pane.rowconfigure(0, weight=3)\n        pane.rowconfigure(1, weight=0)\n        pane.rowconfigure(2, weight=0)\n        pane.columnconfigure(0, weight=1)\n\n        if not hasattr(self, \"text\") or not isinstance(self.text, tk.Text):\n            self.text = tk.Text(pane, wrap=\"word\")\n        self.text.grid(row=0, column=0, sticky=\"nswe\")\n        self.text.tag_configure(\"link\", foreground=\"green\", underline=True)\n        self.text.bind(\n            \"<Button-3>\", getattr(self, \"_show_context_menu\", lambda e: None)\n        )\n\n        if not hasattr(self, \"img_label\"):\n            self.img_label = tk.Label(pane)\n        self.img_label.grid(row=1, column=0, sticky=\"ew\", pady=(8, 0))\n        try:\n            self.img_label.bind(\n                \"<Button-1>\", lambda e: getattr(self, \"toggle_image_size\")()\n            )\n        except Exception:\n            pass\n        # keep hidden until used\n        try:\n            self.img_label.grid_remove()\n        except Exception:\n            pass\n\n        self._build_bottom_toolbar(pane)\n\n    def _build_context_menu(self):\n        self.context_menu = tk.Menu(self, tearoff=0)\n        self.context_menu.add_separator()\n        self.context_menu.add_command(label=\"Memory\u2026\", command=self._open_memory_dialog)\n        self.context_menu.add_command(label=\"Delete\", command=self._on_delete_clicked)\n        self.context_menu.add_separator()\n        self.context_menu.add_command(label=\"Import\u2026\", command=self._import_doc)\n        self.context_menu.add_command(label=\"Export\u2026\", command=self._export_doc)\n\n    def _show_context_menu(self, event):\n        try:\n            self.context_menu.tk_popup(event.x_root, event.y_root)\n        finally:\n            self.context_menu.grab_release()\n\n    # ---------------- Search ----------------\n    def _install_search_ui(self):\n\n        self._search_var = tk.StringVar()\n        self._search_after_id = None\n\n        # place the search row under the buttons\n        existing_rows = [\n        int(w.grid_info().get(\"row\", 0)) for w in self.toolbar.grid_slaves()\n        ]\n        next_row = (max(existing_rows) + 1) if existing_rows else 0\n\n        ttk.Label(self.toolbar, text=\"Search:\").grid(\n            row=next_row, column=0, padx=(2, 2), pady=(6, 2), sticky=\"w\"\n        )\n        self._search_entry = ttk.Entry(\n            self.toolbar, textvariable=self._search_var, width=22\n        )\n        self._search_entry.grid(\n            row=next_row, column=1, padx=(0, 6), pady=(6, 2), sticky=\"ew\"\n        )\n        # Do NOT let the entry stretch the toolbar width\n        # self.toolbar.grid_columnconfigure(1, weight=0)\n\n        self._search_entry.insert(0, \"title or text\u2026\")\n        self._search_entry.bind(\n            \"<FocusIn>\", lambda e: self._search_entry.delete(0, \"end\")\n        )\n        self._search_entry.bind(\n            \"<Return>\", lambda e: self.filter_index(self._search_var.get())\n        )\n\n    def _clear_placeholder(self):\n        if self._search_entry.get() == \"title or text\u2026\":\n            self._search_entry.delete(0, \"end\")\n\n    def _on_search_changed(self):\n        if self._search_after_id:\n            self.after_cancel(self._search_after_id)\n        self._search_after_id = self.after(200, self._apply_search)\n\n    def _apply_search(self):\n        q = (self._search_var.get() or \"\").strip()\n        if not q or q == \"title or text\u2026\":\n            self.refresh_index()\n        else:\n            self.filter_index(q)\n\n    # ---------------- Sidebar / Index ----------------\n    def refresh_index(self):\n        \"\"\"Reload the flat document list into the index pane.\"\"\"\n        self.sidebar.delete(*self.sidebar.get_children())\n        try:\n            rows = (\n                self.doc_store.get_document_index()\n            )  # expected: iterable of dicts {id,title,description}\n        except Exception:\n            rows = []\n        for row in rows:\n            if isinstance(row, dict):\n                doc_id = row.get(\"id\")\n                title = row.get(\"title\", \"\")\n                desc = row.get(\"description\", \"\")\n            elif isinstance(row, (list, tuple)) and len(row) >= 2:\n                doc_id, title = row[0], row[1]\n                desc = row[2] if len(row) > 2 else \"\"\n            else:\n                continue\n            self.sidebar.insert(\"\", \"end\", values=(doc_id, title, desc))\n\n    def filter_index(self, query: str):\n        \"\"\"Filter by title/body. Requires doc_store.search_docs; falls back to naive filtering.\"\"\"\n        self.sidebar.delete(*self.sidebar.get_children())\n        try:\n            matches = self.doc_store.search_docs(\n                query\n            )  # expected rows: (id, title) or dicts\n        except Exception:\n            ql = query.lower()\n            base = getattr(self.doc_store, \"get_document_index\", lambda: [])()\n            matches = [\n                (d[\"id\"], d.get(\"title\", \"\"))\n                for d in base\n                if isinstance(d, dict)\n                and (d.get(\"title\", \"\") + d.get(\"description\", \"\")).lower().find(ql)\n                >= 0\n            ]\n        for row in matches:\n            if isinstance(row, dict):\n                doc_id, title = row.get(\"id\"), row.get(\"title\", \"\")\n            elif isinstance(row, (list, tuple)):\n                doc_id, title = row[0], row[1] if len(row) > 1 else \"\"\n            else:\n                continue\n            self.sidebar.insert(\"\", \"end\", values=(doc_id, title, \"\"))\n\n    def _on_select(self, event):\n        if self._suppress_sidebar_select:\n            return\n        sel = self.sidebar.selection()\n        if not sel:\n            return\n        vals = self.sidebar.item(sel[0], \"values\") or []\n        if not vals:\n            return\n        try:\n            doc_id = int(vals[0])\n        except Exception:\n            return\n        if self.current_doc_id is not None:\n            self.history.append(self.current_doc_id)\n        self.current_doc_id = doc_id\n        self._open_doc_id(doc_id)\n\n    def _select_tree_item_for_doc(self, doc_id: int):\n        tv = self.sidebar\n        found = None\n        for iid in tv.get_children(\"\"):\n            vals = tv.item(iid, \"values\") or ()\n            if vals and str(vals[0]) == str(doc_id):\n                found = iid\n                break\n        if found:\n            prev = self._suppress_sidebar_select\n            try:\n                self._suppress_sidebar_select = True\n                tv.selection_set(found)\n                tv.focus(found)\n                tv.see(found)\n            finally:\n                self.after_idle(lambda: setattr(self, \"_suppress_sidebar_select\", prev))\n\n    # ---------------- TreeView wiring ----------------\n    def on_tree_button(self):\n        \"\"\"Open a TreeView window rooted at current doc (if available).\"\"\"\n        if not tree_view_mod:\n            messagebox.showwarning(\"TreeView\", \"TreeView module not available.\")\n            return\n\n        # Simple adapter based on green links \"(doc:ID)\"\n        class _Repo:\n            def __init__(self, ds):\n                self.ds = ds\n\n            def get_doc(self, doc_id):\n                d = self.ds.get_document(doc_id)\n                if not d:\n                    return None\n                if isinstance(d, dict):\n                    return type(\n                        \"Node\",\n                        (object,),\n                        {\n                            \"id\": d.get(\"id\"),\n                            \"title\": d.get(\"title\") or \"(untitled)\",\n                            \"parent_id\": None,\n                        },\n                    )()\n                return type(\n                    \"Node\",\n                    (object,),\n                    {\n                        \"id\": d[0],\n                        \"title\": (d[1] if len(d) > 1 else \"(untitled)\"),\n                        \"parent_id\": None,\n                    },\n                )()\n\n            def get_children(self, parent_id):\n                if parent_id is None:\n                    ids = [r[\"id\"] for r in self.ds.get_document_index()]\n                    refd = set()\n                    for r in self.ds.get_document_index():\n                        d = self.ds.get_document(r[\"id\"])\n                        body = (\n                            d.get(\"body\")\n                            if isinstance(d, dict)\n                            else (d[2] if len(d) > 2 else \"\")\n                        )\n                        if not isinstance(body, str):\n                            continue\n                        refd.update(int(m) for m in re.findall(r\"\\(doc:(\\d+)\\)\", body))\n                    roots = [self.get_doc(i) for i in ids if i not in refd] or [\n                        self.get_doc(i) for i in ids\n                    ]\n                    return [n for n in roots if n]\n                d = self.ds.get_document(parent_id)\n                body = (\n                    d.get(\"body\")\n                    if isinstance(d, dict)\n                    else (d[2] if len(d) > 2 else \"\")\n                )\n                ids = (\n                    [int(m) for m in re.findall(r\"\\(doc:(\\d+)\\)\", body)]\n                    if isinstance(body, str)\n                    else []\n                )\n                return [self.get_doc(i) for i in ids if self.get_doc(i)]\n\n        win = tree_view_mod(\n            self,\n            repo=_Repo(self.doc_store),\n            on_open_doc=self._open_doc_id,\n            root_doc_id=self.current_doc_id,\n        )\n        # Expand a bit if supported\n        try:\n            if hasattr(win, \"_expand_to_depth\"):\n                win._expand_to_depth(self.opml_expand_depth)\n        except Exception:\n            pass\n\n    # ---------------- Import/Export ----------------\n    def _import_doc(self):\n        path = filedialog.askopenfilename(\n            title=\"Import\",\n            filetypes=[\n                (\"Text\", \"*.txt *.md *.html *.opml *.xml\"),\n                (\"All files\", \"*.*\"),\n            ],\n        )\n        if not path:\n            return\n        try:\n            data = Path(path).read_text(encoding=\"utf-8\", errors=\"replace\")\n        except Exception as e:\n            messagebox.showerror(\"Import\", f\"Failed to read file:\\n{e}\")\n            return\n        title = Path(path).name\n        try:\n            nid = self.doc_store.add_document(title, data)\n        except Exception as e:\n            messagebox.showerror(\"Import\", f\"Failed to add to DB:\\n{e}\")\n            return\n        self.refresh_index()\n        self._open_doc_id(nid)\n        self._select_tree_item_for_doc(nid)\n\n    def _export_doc(self):\n        if self.current_doc_id is None:\n            messagebox.showwarning(\"Export\", \"No document selected.\")\n            return\n        doc = self.doc_store.get_document(self.current_doc_id)\n        if not doc:\n            messagebox.showerror(\"Export\", \"Document not found.\")\n            return\n        if isinstance(doc, dict):\n            title = doc.get(\"title\") or \"Document\"\n            body = doc.get(\"body\") or \"\"\n            ctype = (doc.get(\"content_type\") or \"\").lower()\n        else:\n            title = doc[1] if len(doc) > 1 else \"Document\"\n            body = doc[2] if len(doc) > 2 else \"\"\n            ctype = \"\"\n        safe = (\n            \"\".join(c if (c.isalnum() or c in \"._- \") else \"_\" for c in title).strip()\n            or \"Document\"\n        )\n        ext = \".opml\" if (isinstance(body, str) and \"<opml\" in body.lower()) else \".txt\"\n        path = filedialog.asksaveasfilename(\n            title=\"Export Document\", defaultextension=ext, initialfile=f\"{safe}{ext}\"\n        )\n        if not path:\n            return\n        try:\n            if isinstance(body, (bytes, bytearray)):\n                Path(path).write_bytes(bytes(body))\n            else:\n                Path(path).write_text(body, encoding=\"utf-8\", newline=\"\\n\")\n            messagebox.showinfo(\"Export\", f\"Saved:\\n{path}\")\n        except Exception as e:\n            messagebox.showerror(\"Export\", f\"Could not save:\\n{e}\")\n\n    def _import_directory(self):\n        if not dir_importer:\n            messagebox.showwarning(\n                \"Directory Import\", \"Directory import module not available.\"\n            )\n            return\n        dir_path = filedialog.askdirectory(title=\"Select Folder to Import\")\n        if not dir_path:\n            return\n        try:\n            imported, skipped = dir_importer(dir_path, self.doc_store)\n        except Exception as e:\n            messagebox.showerror(\"Directory Import\", f\"Failed:\\n{e}\")\n            return\n        messagebox.showinfo(\n            \"Directory Import\", f\"Imported {imported} file(s), skipped {skipped}.\"\n        )\n        self.refresh_index()\n\n    # ---------------- Open OPML into DB ----------------\n    def _open_opml_from_main(self):\n        path = filedialog.askopenfilename(\n            title=\"Open OPML/XML\",\n            filetypes=[(\"OPML / XML\", \"*.opml *.xml\"), (\"All files\", \"*.*\")],\n        )\n        if not path:\n            return\n        try:\n            content = Path(path).read_text(encoding=\"utf-8\", errors=\"replace\")\n        except Exception as e:\n            messagebox.showerror(\"Open OPML\", f\"Failed to read file:\\n{e}\")\n            return\n        title = Path(path).stem\n        try:\n            new_id = self.doc_store.add_document(title, content)\n        except Exception as e:\n            messagebox.showerror(\"Open OPML\", f\"Failed to import OPML to DB:\\n{e}\")\n            return\n        self.refresh_index()\n        self._open_doc_id(new_id)\n        self._select_tree_item_for_doc(new_id)\n\n    # ---------------- Rendering ----------------\n    def _open_doc_id(self, doc_id: int):\n        doc = self.doc_store.get_document(doc_id)\n        if not doc:\n            return\n        self.current_doc_id = doc_id\n        self._render_document(doc)\n\n    def _render_document(self, doc):\n        \"\"\"Render text, OPML-as-tree, or local image bytes.\"\"\"\n        # normalize tuple/dict\n        if isinstance(doc, dict):\n            body = doc.get(\"body\")\n            ctype = (doc.get(\"content_type\") or \"\").lower()\n            title = doc.get(\"title\") or \"\"\n        else:\n            body = doc[2] if len(doc) > 2 else \"\"\n            ctype = \"\"\n            title = doc[1] if len(doc) > 1 else \"\"\n\n        # OPML detection\n        if isinstance(body, str) and \"<opml\" in body.lower():\n            self._render_opml_from_string(body)\n            return\n\n        # hide OPML tree if showing\n        self._hide_opml()\n\n        # IMAGE (local bytes only)\n        if isinstance(body, (bytes, bytearray)) and _HAVE_PIL:\n            self._show_image_bytes(body, title, ctype)\n            return\n\n        # Plain text / HTML\n        self.text.delete(\"1.0\", tk.END)\n        if isinstance(body, (bytes, bytearray)):\n            try:\n                body = body.decode(\"utf-8\")\n            except Exception:\n                body = body.decode(\"latin-1\", errors=\"replace\")\n        self.text.insert(\"1.0\", body or \"\")\n        # link parsing if module exists\n        try:\n            if hypertext_parser:\n                hypertext_parser.parse_links(\n                    self.text, body or \"\", self._on_green_link_click\n                )\n        except Exception:\n            pass\n\n    def _on_green_link_click(self, doc_id):\n        if self.current_doc_id is not None:\n            self.history.append(self.current_doc_id)\n        self._open_doc_id(int(doc_id))\n\n    # ---- OPML widgets ----\n    def _ensure_opml_widgets(self):\n        if hasattr(self, \"_opml_frame\") and self._opml_frame.winfo_exists():\n            return\n        pane = self.text.master\n        self._opml_frame = tk.Frame(pane)\n        self._opml_frame.grid(row=0, column=0, sticky=\"nswe\")\n        tb = tk.Frame(self._opml_frame)\n        tb.pack(side=tk.TOP, fill=tk.X)\n        self._opml_show_nums = tk.BooleanVar(value=True)\n        ttk.Checkbutton(\n            tb,\n            text=\"Show Numbers\",\n            variable=self._opml_show_nums,\n            command=self._opml_update_numbering,\n        ).pack(side=tk.LEFT, padx=6)\n        self._opml_tree = ttk.Treeview(\n            self._opml_frame, columns=(\"num\",), show=\"tree headings\"\n        )\n        self._opml_tree.heading(\"num\", text=\"No.\")\n        self._opml_tree.column(\"num\", width=90, minwidth=60, stretch=False, anchor=\"e\")\n        vsb = ttk.Scrollbar(\n            self._opml_frame, orient=\"vertical\", command=self._opml_tree.yview\n        )\n        hsb = ttk.Scrollbar(\n            self._opml_frame, orient=\"horizontal\", command=self._opml_tree.xview\n        )\n        self._opml_tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)\n        self._opml_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        vsb.pack(side=tk.RIGHT, fill=tk.Y)\n        hsb.pack(side=tk.BOTTOM, fill=tk.X)\n\n    def _show_opml(self):\n        self._ensure_opml_widgets()\n        if self.text.winfo_manager():\n            self.text.grid_remove()\n        self._opml_frame.lift()\n        self._opml_frame.grid()\n\n    def _hide_opml(self):\n        if hasattr(self, \"_opml_frame\") and self._opml_frame.winfo_exists():\n            self._opml_frame.grid_remove()\n        if not self.text.winfo_manager():\n            self.text.grid(row=0, column=0, sticky=\"nswe\")\n\n    def _render_opml_from_string(self, s: str):\n        try:\n            s = s.decode(\"utf-8\") if isinstance(s, (bytes, bytearray)) else s\n            s = (s or \"\").lstrip(\"\\ufeff\\r\\n\\t \")\n            root = ET.fromstring(s)\n        except Exception as e:\n            print(\"[OPML] parse failed:\", e)\n            # fallback: just show text\n            self._hide_opml()\n            self.text.delete(\"1.0\", tk.END)\n            self.text.insert(\"1.0\", s or \"\")\n            return\n        if (root.tag or \"\").lower() != \"opml\":\n            self._hide_opml()\n            self.text.delete(\"1.0\", tk.END)\n            self.text.insert(\"1.0\", s or \"\")\n            return\n\n        self._show_opml()\n        for iid in self._opml_tree.get_children(\"\"):\n            self._opml_tree.delete(iid)\n\n        body = None\n        for child in root:\n            if child.tag.lower().endswith(\"body\"):\n                body = child\n                break\n        outlines = body.findall(\"outline\") if body is not None else list(root)\n\n        def insert_elem(parent_iid, elem):\n            text = (\n                elem.attrib.get(\"text\")\n                or elem.attrib.get(\"title\")\n                or (elem.text.strip() if elem.text else \"\")\n                or \"[No Text]\"\n            )\n            iid = self._opml_tree.insert(parent_iid, \"end\", text=text)\n            for c in elem:\n                tag = (c.tag or \"\").lower()\n                if tag.endswith(\"outline\") or tag in {\"outline\", \"node\", \"item\"}:\n                    insert_elem(iid, c)\n\n        for e in outlines:\n            tag = (e.tag or \"\").lower()\n            if tag.endswith(\"outline\") or tag in {\"outline\", \"node\", \"item\"}:\n                insert_elem(\"\", e)\n\n        self._opml_expand_to_depth_in_pane(self.opml_expand_depth)\n        self._opml_update_numbering()\n\n    def _opml_expand_to_depth_in_pane(self, depth: int):\n        if not hasattr(self, \"_opml_tree\"):\n            return\n\n        def walk(iid, d):\n            if d >= depth:\n                return\n            self._opml_tree.item(iid, open=True)\n            for c in self._opml_tree.get_children(iid):\n                walk(c, d + 1)\n\n        for top in self._opml_tree.get_children(\"\"):\n            walk(top, 0)\n\n    def _opml_update_numbering(self):\n        if not hasattr(self, \"_opml_tree\"):\n            return\n        try:\n            show = bool(self._opml_show_nums.get())\n        except Exception:\n            show = True\n        if not show:\n            self._opml_tree.column(\"num\", width=0, minwidth=0, stretch=False)\n            for c in self._opml_tree.get_children(\"\"):\n                self._opml_tree.set(c, \"num\", \"\")\n            return\n        self._opml_tree.column(\"num\", width=90, minwidth=60, stretch=False, anchor=\"e\")\n\n        def renumber(iid=\"\", prefix=None):\n            if prefix is None:\n                prefix = []\n            kids = self._opml_tree.get_children(iid)\n            for idx, c in enumerate(kids, start=1):\n                parts = prefix + [idx]\n                self._opml_tree.set(c, \"num\", \".\".join(str(n) for n in parts))\n                renumber(c, parts)\n\n        renumber(\"\")\n\n    # ---------------- Image helpers ----------------\n    def _show_image_bytes(self, data: bytes, title: str, ctype: str):\n        if not _HAVE_PIL:\n            self.text.delete(\"1.0\", tk.END)\n            self.text.insert(\"1.0\", \"[Image support unavailable]\")\n            return\n        from io import BytesIO\n\n        try:\n            pil_img = Image.open(BytesIO(bytes(data)))\n            thumb = pil_img.copy()\n            thumb.thumbnail((900, 500))\n            tk_img = ImageTk.PhotoImage(thumb)\n            self.img_label.configure(image=tk_img)\n            self.img_label.image = tk_img\n            self.img_label.grid(row=0, column=0, sticky=\"ew\", pady=(6, 0))\n            self.text.delete(\"1.0\", tk.END)\n            self.text.insert(\"1.0\", f\"{title or 'Image'} ({ctype or 'image'})\\n\")\n        except Exception as e:\n            self.text.delete(\"1.0\", tk.END)\n            self.text.insert(\"1.0\", f\"[image decode failed: {e}]\")\n\n    # ---------------- Delete ----------------\n    def _on_delete_clicked(self):\n        sel = self.sidebar.selection()\n        if not sel:\n            messagebox.showwarning(\"Delete\", \"No document selected.\")\n            return\n        vals = self.sidebar.item(sel[0], \"values\") or []\n        if not vals:\n            return\n        try:\n            nid = int(vals[0])\n        except Exception:\n            return\n        if not messagebox.askyesno(\"Confirm Delete\", f\"Delete document ID {nid}?\"):\n            return\n        try:\n            self.doc_store.delete_document(nid)\n        except Exception as e:\n            messagebox.showerror(\"Delete\", f\"Failed to delete: {e}\")\n            return\n        self.refresh_index()\n        self.text.delete(\"1.0\", tk.END)\n        if hasattr(self, \"_opml_frame\") and self._opml_frame.winfo_exists():\n            self._opml_frame.grid_remove()\n        if hasattr(self.img_label, \"image\"):\n            self.img_label.configure(image=\"\")\n            self.img_label.image = None\n        self.current_doc_id = None\n        messagebox.showinfo(\"Deleted\", f\"Document {nid} deleted.\")\n\n    # ---------------- Settings helpers ----------------\n    def _set_opml_expand_depth(self):\n        try:\n            val = simpledialog.askinteger(\n                \"OPML Expand Depth\",\n                \"How deep to expand OPML trees (1\u20136)?\",\n                parent=self,\n                minvalue=1,\n                maxvalue=6,\n                initialvalue=self.opml_expand_depth,\n            )\n            if val:\n                self.opml_expand_depth = int(val)\n                self._save_settings()\n                # update current OPML pane if visible\n                try:\n                    self._opml_expand_to_depth_in_pane(self.opml_expand_depth)\n                    self._opml_update_numbering()\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n    def _on_ask(self):\n\n        prefix = simpledialog.askstring(\n            \"ASK prefix\", \"Enter prefix:\", initialvalue=\"Please expand on this:\"\n        )\n        if prefix is None:\n            return\n        try:\n            sel = self.text.get(\"sel.first\", \"sel.last\")\n        except Exception:\n            sel = \"\"\n            if not sel.strip():\n                messagebox.showinfo(\"ASK\", \"Select some text to ask about.\")\n                return\n\n        current_id = getattr(self, \"current_doc_id\", None)\n        if current_id is None:\n            messagebox.showerror(\"ASK\", \"No active document is loaded.\")\n            return\n\n        self.processor.query_ai(\n            selected_text=sel,\n            current_doc_id=current_id,\n            on_success=lambda new_id: messagebox.showinfo(\n                \"ASK\", f\"Created new document {new_id}\", prefix=prefix\n            ),\n            on_link_created=lambda _t: self.render_document(current_id),\n            prefix=\"Please expand on this:\",\n        )\n\n    def _go_back(self):\n        if not getattr(self, \"history\", None):\n            messagebox.showinfo(\"BACK\", \"No history.\")\n        prev = self.history.pop() \n        self.current_doc_id = prev\n        doc = self.doc_store.get_document(prev)\n        if doc:\n            self._render_document(doc)\n        else:\n            messagebox.showerror(\"BACK\", f\"Document {prev} not found.\")\n        if self.current_doc_id is not None:\n            self.history.append(self.current_doc_id)\n        if self.current_doc_id is not None:\n           self._open_doc_id(doc_id)\n\n    def _on_search_clicked(self):\n        q = simpledialog.askstring(\"Search\", \"Enter query:\")\n        if q:\n            self.filter_index(q)\n"
}