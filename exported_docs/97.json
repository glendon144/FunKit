{
  "id": 97,
  "title": "gui_tkinter_merged",
  "body": "# gui_tkinter.py \u2014 Universal, compatibility-hardened GUI for FunKit/DemoKit\n# Release: v1.31 (2025-08-23)\n#\n# Key features:\n# - Restored image rendering (BLOB + Base64 string/bytes)\n# - OPML outline view (expandable Treeview)\n# - Sidebar previews + Size column\n# - File menu, context menu, Export, Save as Text\n# - Flask \u201cIntraweb\u201d server button\n# - ASK + green link refresh stable\n# - Reparse Links working\n# This build borrows the proven image workflow (label + thumbnail + zoom window) from your phase2_3 prefs file\n# while keeping all universal shims and features.\n\nfrom __future__ import annotations\n\nimport base64\nfrom io import BytesIO\nfrom pathlib import Path\nimport sqlite3\nimport tkinter as tk\nfrom tkinter import ttk, filedialog, simpledialog, messagebox\nfrom typing import Any, Tuple, Optional\nimport xml.etree.ElementTree as ET\n\n# ---- Optional image support (Pillow) ----\ntry:\n    from PIL import Image, ImageTk  # type: ignore\n\n    PIL_AVAILABLE = True\nexcept Exception:\n    PIL_AVAILABLE = False\n\n\n# ---- Safe importer ----\ndef _try_import(modpath: str, name: str | None = None, default=None):\n    try:\n        mod = __import__(modpath, fromlist=[\"*\"])\n        return getattr(mod, name, mod) if name else mod\n    except Exception:\n        return default\n\n\n# ---- Primary module names ----\ncommand_processor_mod = _try_import(\"modules.command_processor\")\ndocument_store_mod = _try_import(\"modules.document_store\")\nhypertext_parser_mod = _try_import(\"modules.hypertext_parser\")\nrenderer_mod = _try_import(\"modules.renderer\")\nopml_plugin = _try_import(\"modules.opml_extras_plugin_v3\")\nlogger_mod = _try_import(\"modules.logger\")\nflask_server_path = Path(\"modules\") / \"flask_server.py\"\n\n# ---- Legacy/alternate module names (shims) ----\nif command_processor_mod is None:\n    command_processor_mod = _try_import(\"modules.cmdprocessor\")\nif hypertext_parser_mod is None:\n    hypertext_parser_mod = _try_import(\"modules.hypertextparser\")\n\n# Resolve CP class (CommandProcessor or CmdProcessor)\nCommandProcessor = None\nif command_processor_mod:\n    CommandProcessor = getattr(\n        command_processor_mod,\n        \"CommandProcessor\",\n        getattr(command_processor_mod, \"CmdProcessor\", None),\n    )\n\n# Resolve link parser function(s)\nparse_links = None\nif hypertext_parser_mod:\n    for fname in (\"parse_links\", \"parse_links_v2\", \"reparse_links\"):\n        parse_links = getattr(hypertext_parser_mod, fname, None)\n        if callable(parse_links):\n            break\n\n# Optional renderer helpers\nrender_binary_preview = getattr(renderer_mod or object(), \"render_binary_preview\", None)\nrender_binary_as_text = getattr(renderer_mod or object(), \"render_binary_as_text\", None)\n\n# Logger\nLogger = getattr(logger_mod or object(), \"Logger\", None)\n\n# ---------- Helpers ----------\n\n\ndef _human_size(n: int) -> str:\n    for unit in (\"B\", \"KB\", \"MB\", \"GB\"):\n        if n < 1024 or unit == \"GB\":\n            return f\"{n:.0f} {unit}\" if unit == \"B\" else f\"{n/1024:.1f} {unit}\"\n        n /= 1024\n    return f\"{n:.1f} GB\"\n\n\ndef _extract_title_content(doc: Any) -> Tuple[str, Any]:\n    \"\"\"Return (title, content) from dict / sqlite3.Row / list/tuple / other.\"\"\"\n    # sqlite3.Row \u2192 dict\n    if isinstance(doc, sqlite3.Row):\n        m = dict(doc)\n        title = str(m.get(\"title\", m.get(\"name\", m.get(\"heading\", \"\"))) or \"\")\n        # Prefer textual content fields\n        for key in (\"content\", \"body\", \"text\", \"raw\", \"data\", \"value\", \"description\"):\n            if key in m and m[key] not in (None, \"\"):\n                return title, m[key]\n        # Fallback: longest string\n        best = \"\"\n        for v in m.values():\n            if isinstance(v, str) and len(v) > len(best):\n                best = v\n        return title, best if best else str(m)\n\n    # dict\n    if isinstance(doc, dict):\n        title = str(doc.get(\"title\", doc.get(\"name\", doc.get(\"heading\", \"\"))) or \"\")\n        for key in (\"content\", \"body\", \"text\", \"raw\", \"data\", \"value\", \"description\"):\n            if key in doc and doc[key] not in (None, \"\"):\n                return title, doc[key]\n        # fallback\n        best = \"\"\n        for v in doc.values():\n            if isinstance(v, str) and len(v) > len(best):\n                best = v\n        return title, best if best else str(doc)\n\n    # tuple/list\n    if isinstance(doc, (list, tuple)):\n        title = \"\"\n        if len(doc) > 1 and isinstance(doc[1], str):\n            title = doc[1]\n        # choose longest string as content\n        str_elems = [s for s in doc if isinstance(s, str)]\n        if str_elems:\n            content_val = max(str_elems, key=len)\n            return title, content_val\n        # else bytes\n        for v in doc:\n            if isinstance(v, (bytes, bytearray)):\n                return title, v\n        return title, str(doc)\n\n    return \"\", str(doc)\n\n\n_BASE64_CHARS = set(\n    b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\r\\n \\t\"\n)\n\n\ndef _looks_like_b64_text(s: str) -> bool:\n    if not isinstance(s, str) or len(s) < 200:\n        return False\n    # strip header\n    i = s.find(\"base64,\")\n    payload = s[i + 7 :] if i != -1 else s\n    payload = \"\".join(payload.split())\n    if len(payload) % 4 != 0:\n        return False\n    head = payload[:200]\n    return all(ord(ch) < 128 and ch.encode() in _BASE64_CHARS for ch in head)\n\n\ndef _decode_b64_text(s: str) -> Optional[bytes]:\n    i = s.find(\"base64,\")\n    payload = s[i + 7 :] if i != -1 else s\n    payload = \"\".join(payload.split())\n    try:\n        return base64.b64decode(payload, validate=True)\n    except Exception:\n        try:\n            missing = (-len(payload)) % 4\n            return base64.b64decode(payload + (\"=\" * missing))\n        except Exception:\n            return None\n\n\ndef _looks_like_b64_bytes(b: bytes) -> bool:\n    if not isinstance(b, (bytes, bytearray)) or len(b) < 200:\n        return False\n    head = b[:400]\n    if any(ch not in _BASE64_CHARS for ch in head):\n        return False\n    stripped = b\"\".join(ch for ch in b if ch in _BASE64_CHARS)\n    return len(stripped) % 4 == 0\n\n\ndef _decode_b64_bytes(b: bytes) -> Optional[bytes]:\n    payload = b\"\".join(ch for ch in b if ch in _BASE64_CHARS)\n    try:\n        return base64.b64decode(payload, validate=True)\n    except Exception:\n        try:\n            missing = (-len(payload)) % 4\n            return base64.b64decode(payload + b\"=\" * missing)\n        except Exception:\n            return None\n\n\ndef _make_preview(title: str, content: Any) -> str:\n    generic = {\"ai response\", \"response\", \"untitled\", \"\"}\n    tnorm = (title or \"\").strip().lower()\n    if tnorm not in generic and not tnorm.startswith(\"opml\"):\n        return title\n    if isinstance(content, str) and content.strip():\n        words = content.strip().split()\n        preview = \" \".join(words[:10])\n        return (preview + \"\u2026\") if len(words) > 10 else preview\n    return title or \"(untitled)\"\n\n\n# ---------- App ----------\n\n\nclass App(tk.Tk):\n    def __init__(self, *args, **kwargs):\n        doc_store_pos = args[0] if len(args) >= 1 else None\n        processor_pos = args[1] if len(args) >= 2 else None\n\n        super().__init__()\n        self.title(\"FunKit / DemoKit \u2014 GUI v1.31\")\n\n        self.geometry(\"1180x780\")\n\n        # Public state\n        self.current_doc_id: int | None = None\n        self.history: list[int] = []\n        self._last_selection: Tuple[str, str] | None = None\n        self._current_content: str | bytes | None = None  # for Reparse Links\n        self._mode: str = \"text\"  # 'text' or 'opml'\n        self._last_pil_img: Optional[Image.Image] = None\n        self._last_tk_img: Optional[ImageTk.PhotoImage] = None\n        self._image_zoom_win: Optional[tk.Toplevel] = None\n\n        self.doc_store = kwargs.get(\"doc_store\") or doc_store_pos\n        self.processor = kwargs.get(\"processor\") or processor_pos\n        self.logger = getattr(self.processor, \"logger\", Logger() if Logger else None)\n\n        if (\n            self.doc_store is None\n            and document_store_mod\n            and hasattr(document_store_mod, \"DocumentStore\")\n        ):\n            try:\n                self.doc_store = document_store_mod.DocumentStore()\n            except Exception as e:\n                print(\"Warning: DocumentStore failed to init:\", e)\n\n        if self.processor is None and CommandProcessor:\n            try:\n                self.processor = CommandProcessor()\n            except Exception as e:\n                print(\"Warning: CommandProcessor failed to init:\", e)\n\n        self._build_ui()\n        self._refresh_index()\n\n    # ---------- UI ----------\n    def _build_ui(self):\n        root = self\n\n        # Menubar (File + OPML + View)\n        menubar = tk.Menu(root)\n        filemenu = tk.Menu(menubar, tearoff=0)\n        filemenu.add_command(label=\"Import Text\u2026\", command=self._import_text_file)\n        filemenu.add_command(label=\"Export Current\u2026\", command=self._export_current)\n        filemenu.add_separator()\n        filemenu.add_command(\n            label=\"Export to Intraweb (Flask)\u2026\", command=self._export_and_launch_flask\n        )\n        filemenu.add_separator()\n        filemenu.add_command(label=\"Quit\", command=self.destroy)\n        menubar.add_cascade(label=\"File\", menu=filemenu)\n\n        opmlmenu = tk.Menu(menubar, tearoff=0)\n        opmlmenu.add_command(label=\"Open OPML/XML\u2026\", command=self._open_opml_from_file)\n        opmlmenu.add_command(\n            label=\"Convert Selection \u2192 OPML\", command=self._convert_selection_to_opml\n        )\n        menubar.add_cascade(label=\"OPML\", menu=opmlmenu)\n\n        root.config(menu=menubar)\n\n        # Toolbar\n        bar = ttk.Frame(root)\n        bar.pack(side=\"top\", fill=\"x\")\n\n        ttk.Button(bar, text=\"Ask\", command=self._on_ask).pack(\n            side=\"left\", padx=4, pady=4\n        )\n        ttk.Button(bar, text=\"Back\", command=self._go_back).pack(\n            side=\"left\", padx=4, pady=4\n        )\n        ttk.Button(bar, text=\"Open by ID\", command=self._open_by_id).pack(\n            side=\"left\", padx=4, pady=4\n        )\n\n        ttk.Separator(bar, orient=\"vertical\").pack(side=\"left\", fill=\"y\", padx=6)\n\n        ttk.Button(bar, text=\"Import Dir\", command=self._import_directory).pack(\n            side=\"left\", padx=4, pady=4\n        )\n        ttk.Button(bar, text=\"Open OPML\", command=self._open_opml_from_file).pack(\n            side=\"left\", padx=4, pady=4\n        )\n        ttk.Button(\n            bar, text=\"Convert \u2192 OPML\", command=self._convert_selection_to_opml\n        ).pack(side=\"left\", padx=4, pady=4)\n\n        ttk.Separator(bar, orient=\"vertical\").pack(side=\"left\", fill=\"y\", padx=6)\n\n        ttk.Button(bar, text=\"Search\", command=self._on_search_clicked).pack(\n            side=\"left\", padx=4, pady=4\n        )\n        ttk.Button(bar, text=\"Reparse Links\", command=self._reparse_links).pack(\n            side=\"left\", padx=4, pady=4\n        )\n        ttk.Button(bar, text=\"Flask\", command=self._export_and_launch_flask).pack(\n            side=\"left\", padx=4, pady=4\n        )\n\n        # Panes\n        self.panes = ttk.Panedwindow(root, orient=\"horizontal\")\n        self.panes.pack(fill=\"both\", expand=True)\n\n        # Left: index\n        left = ttk.Frame(self.panes)\n        self.sidebar = ttk.Treeview(\n            left, columns=(\"id\", \"title\", \"size\"), show=\"headings\", height=20\n        )\n        self.sidebar.heading(\"id\", text=\"ID\")\n        self.sidebar.heading(\"title\", text=\"Title / Preview\")\n        self.sidebar.heading(\"size\", text=\"Size\")\n        self.sidebar.column(\"id\", width=80, anchor=\"w\")\n        self.sidebar.column(\"title\", width=420, anchor=\"w\")\n        self.sidebar.column(\"size\", width=90, anchor=\"e\")\n        self.sidebar.pack(fill=\"both\", expand=True)\n        self.sidebar.bind(\"<<TreeviewSelect>>\", self._on_sidebar_select)\n\n        left_bottom = ttk.Frame(left)\n        left_bottom.pack(fill=\"x\")\n        ttk.Button(left_bottom, text=\"Refresh\", command=self._refresh_index).pack(\n            side=\"left\", padx=4, pady=4\n        )\n        self.panes.add(left, weight=1)\n\n        # Right stack: Text pane + Image label + OPML tree\n        right = ttk.Frame(self.panes)\n        self.right_stack = ttk.Frame(right)\n        self.right_stack.pack(fill=\"both\", expand=True)\n\n        # Text mode widgets\n        self.text_frame = ttk.Frame(self.right_stack)\n        self.text = tk.Text(self.text_frame, wrap=\"word\", undo=True)\n        yscroll = ttk.Scrollbar(\n            self.text_frame, orient=\"vertical\", command=self.text.yview\n        )\n        self.text.configure(yscrollcommand=yscroll.set)\n        self.text.pack(side=\"top\", fill=\"both\", expand=True)\n        yscroll.pack(side=\"right\", fill=\"y\")\n\n        # Image label (below text)\n        self.img_label = tk.Label(self.text_frame)\n        self.img_label.pack(side=\"bottom\", fill=\"x\", pady=(6, 0))\n        self.img_label.bind(\"<Button-1>\", lambda e: self._toggle_image_zoom())\n\n        # Context menu on text\n        self.text.bind(\"<Button-3>\", self._show_context_menu)\n\n        # OPML Tree mode widgets\n        self.tree_frame = ttk.Frame(self.right_stack)\n        self.opml_tree = ttk.Treeview(self.tree_frame, show=\"tree\")\n        tree_scroll = ttk.Scrollbar(\n            self.tree_frame, orient=\"vertical\", command=self.opml_tree.yview\n        )\n        self.opml_tree.configure(yscrollcommand=tree_scroll.set)\n        self.opml_tree.pack(side=\"left\", fill=\"both\", expand=True)\n        tree_scroll.pack(side=\"left\", fill=\"y\")\n\n        # Start in text mode\n        self._show_text_mode()\n\n        self.panes.add(right, weight=3)\n\n        # Status\n        self.status = tk.StringVar(value=\"Ready\")\n        ttk.Label(root, textvariable=self.status, anchor=\"w\").pack(\n            side=\"bottom\", fill=\"x\"\n        )\n\n        # Context menu\n        self.context_menu = tk.Menu(root, tearoff=0)\n        self.context_menu.add_command(label=\"Ask\", command=self._on_ask)\n        self.context_menu.add_command(\n            label=\"Export Current\u2026\", command=self._export_current\n        )\n        self.context_menu.add_separator()\n        self.context_menu.add_command(\n            label=\"Save Visible Text\u2026\", command=self._save_visible_text\n        )\n\n        # Shortcuts\n        root.bind_all(\"<Control-Return>\", lambda e: self._on_ask())\n        root.bind_all(\"<Control-Shift-O>\", lambda e: self._convert_selection_to_opml())\n        root.bind_all(\"<Control-u>\", lambda e: self._open_opml_from_file())\n\n    def _show_context_menu(self, event):\n        try:\n            self.context_menu.tk_popup(event.x_root, event.y_root)\n        finally:\n            self.context_menu.grab_release()\n\n    # ---------- Mode switching ----------\n    def _show_text_mode(self):\n        self._mode = \"text\"\n        self.tree_frame.pack_forget()\n        self.text_frame.pack(fill=\"both\", expand=True)\n\n    def _show_tree_mode(self):\n        self._mode = \"opml\"\n        self.text_frame.pack_forget()\n        self.tree_frame.pack(fill=\"both\", expand=True)\n\n    # ---------- Selection handling ----------\n    def _on_text_selection_changed(self, event=None):\n        if self._mode != \"text\":\n            self._last_selection = None\n            return\n        try:\n            start = self.text.index(\"sel.first\")\n            end = self.text.index(\"sel.last\")\n            self._last_selection = (start, end)\n        except Exception:\n            self._last_selection = None\n\n    def _get_selected_text(self) -> str:\n        if self._mode != \"text\":\n            return \"\"\n        try:\n            return self.text.get(\"sel.first\", \"sel.last\")\n        except Exception:\n            pass\n        if self._last_selection:\n            s, e = self._last_selection\n            try:\n                return self.text.get(s, e)\n            except Exception:\n                return \"\"\n        return \"\"\n\n    # ---------- Index / navigation ----------\n    def _approx_payload_size(self, content: Any) -> int:\n        if isinstance(content, (bytes, bytearray)):\n            # Could be image bytes OR base64 text as bytes\n            if _looks_like_b64_bytes(content):\n                b = _decode_b64_bytes(content)\n                return len(b) if b else len(content)\n            return len(content)\n        if isinstance(content, str):\n            if _looks_like_b64_text(content):\n                b = _decode_b64_text(content)\n                return len(b) if b else len(content)\n            return len(content.encode(\"utf-8\", errors=\"ignore\"))\n        return 0\n\n    def _refresh_index(self):\n        try:\n            self.sidebar.delete(*self.sidebar.get_children())\n        except Exception:\n            return\n\n        rows = []\n        if self.doc_store and hasattr(self.doc_store, \"get_document_index\"):\n            try:\n                rows = self.doc_store.get_document_index() or []\n            except Exception as e:\n                print(\"get_document_index failed:\", e)\n\n        for row in rows:\n            # Support dict/Row/tuple\n            if isinstance(row, sqlite3.Row):\n                m = dict(row)\n                doc_id = m.get(\"id\", m.get(\"doc_id\", m.get(\"pk\", None)))\n                title = str(m.get(\"title\", m.get(\"name\", \"\")) or \"\")\n                content = (\n                    m.get(\"content\")\n                    or m.get(\"body\")\n                    or m.get(\"text\")\n                    or m.get(\"raw\")\n                    or m.get(\"data\")\n                    or m.get(\"value\")\n                    or m.get(\"description\")\n                    or \"\"\n                )\n            elif isinstance(row, dict):\n                doc_id = row.get(\"id\") or row.get(\"doc_id\") or row.get(\"pk\")\n                title = str(row.get(\"title\", row.get(\"name\", \"\")) or \"\")\n                content = (\n                    row.get(\"content\")\n                    or row.get(\"body\")\n                    or row.get(\"text\")\n                    or row.get(\"raw\")\n                    or row.get(\"data\")\n                    or row.get(\"value\")\n                    or row.get(\"description\")\n                    or \"\"\n                )\n            else:\n                # tuple/list\n                doc_id = (\n                    row[0] if isinstance(row, (list, tuple)) and len(row) > 0 else None\n                )\n                title = (\n                    row[1]\n                    if isinstance(row, (list, tuple))\n                    and len(row) > 1\n                    and isinstance(row[1], str)\n                    else \"\"\n                )\n                content = (\n                    row[2] if isinstance(row, (list, tuple)) and len(row) > 2 else \"\"\n                )\n\n            preview = _make_preview(title, content)\n            size = self._approx_payload_size(content)\n            self.sidebar.insert(\"\", \"end\", values=(doc_id, preview, _human_size(size)))\n\n    def _on_sidebar_select(self, event=None):\n        sel = self.sidebar.selection()\n        if not sel:\n            return\n        item = self.sidebar.item(sel[0])\n        vals = item.get(\"values\") or []\n        if not vals:\n            return\n        doc_id = vals[0]\n        self._open_doc_id(doc_id)\n\n    def _open_doc_id(self, doc_id):\n        try:\n            doc_id = int(doc_id)\n        except Exception:\n            messagebox.showerror(\"Open\", f\"Invalid document id: {doc_id}\")\n            return\n\n        if self.current_doc_id is not None:\n            self.history.append(self.current_doc_id)\n\n        doc = None\n        if self.doc_store and hasattr(self.doc_store, \"get_document\"):\n            try:\n                doc = self.doc_store.get_document(doc_id)\n            except Exception as e:\n                print(\"get_document failed:\", e)\n        if not doc:\n            messagebox.showerror(\"Open\", f\"Document {doc_id} not found.\")\n            return\n\n        self.current_doc_id = doc_id\n        self._render_document(doc)\n\n    # ---------- Render ----------\n    def _looks_like_opml(self, text: str) -> bool:\n        t = text.strip()\n        if \"<opml\" in t[:200].lower():\n            return True\n        if t.startswith(\"<?xml\") and \"<opml\" in t.lower():\n            return True\n        return False\n\n    def _render_opml_outline(self, xml_text: str):\n        \"\"\"Render OPML as an expandable outline using a Treeview.\"\"\"\n        try:\n            s = xml_text.lstrip(\"\\ufeff\\r\\n\\t \")\n            root = ET.fromstring(s)\n        except Exception as e:\n            # Fall back to plain text if parsing fails\n            self._show_text_mode()\n            self.text.delete(\"1.0\", \"end\")\n            self.text.insert(\"1.0\", xml_text)\n            self.status.set(f\"OPML parse failed: {e}; showing raw XML\")\n            return\n\n        self._show_tree_mode()\n        self.opml_tree.delete(*self.opml_tree.get_children())\n\n        body = root.find(\".//body\")\n        outlines = body.findall(\"outline\") if body is not None else []\n\n        def node_label(elem: ET.Element) -> str:\n            for attr in (\"text\", \"title\"):\n                if elem.get(attr):\n                    return elem.get(attr)  # type: ignore\n            for attr in (\"url\", \"htmlUrl\", \"xmlUrl\"):\n                if elem.get(attr):\n                    return elem.get(attr)  # type: ignore\n            return \"(item)\"\n\n        def add_outline(e: ET.Element, parent=\"\"):\n            this_id = self.opml_tree.insert(parent, \"end\", text=node_label(e))\n            for child in e.findall(\"outline\"):\n                add_outline(child, this_id)\n\n        for top in outlines:\n            add_outline(top, \"\")\n\n        for child in self.opml_tree.get_children(\"\"):\n            self.opml_tree.item(child, open=True)\n\n    def _set_img_label(self, pil_img: Image.Image):\n        # Size to fit window-ish\n        w = max(100, self.winfo_width() - 40)\n        h = max(100, self.winfo_height() - 180)  # leave room for text/status\n        img = pil_img.copy()\n        img.thumbnail((w, h))\n        self._last_pil_img = pil_img\n        self._last_tk_img = ImageTk.PhotoImage(img)\n        self.img_label.configure(image=self._last_tk_img)\n\n    def _hide_image(self):\n        self.img_label.configure(image=\"\")\n        self._last_pil_img = None\n        self._last_tk_img = None\n        if self._image_zoom_win and self._image_zoom_win.winfo_exists():\n            try:\n                self._image_zoom_win.destroy()\n            except Exception:\n                pass\n        self._image_zoom_win = None\n\n    def _toggle_image_zoom(self):\n        if not self._last_pil_img:\n            return\n        if self._image_zoom_win and self._image_zoom_win.winfo_exists():\n            self._image_zoom_win.destroy()\n            self._image_zoom_win = None\n            return\n        win = tk.Toplevel(self)\n        win.title(\"Image Preview\")\n        sw, sh = self.winfo_screenwidth(), self.winfo_screenheight()\n        iw, ih = self._last_pil_img.size\n        win.geometry(f\"{min(iw, sw)}x{min(ih, sh)}\")\n        canvas = tk.Canvas(win, scrollregion=(0, 0, iw, ih))\n        hbar = ttk.Scrollbar(win, orient=\"horizontal\", command=canvas.xview)\n        vbar = ttk.Scrollbar(win, orient=\"vertical\", command=canvas.yview)\n        canvas.configure(xscrollcommand=hbar.set, yscrollcommand=vbar.set)\n        canvas.grid(row=0, column=0, sticky=\"nsew\")\n        hbar.grid(row=1, column=0, sticky=\"we\")\n        vbar.grid(row=0, column=1, sticky=\"ns\")\n        win.grid_rowconfigure(0, weight=1)\n        win.grid_columnconfigure(0, weight=1)\n        tk_img = ImageTk.PhotoImage(self._last_pil_img)\n        canvas.create_image(0, 0, anchor=\"nw\", image=tk_img)\n        canvas.image = tk_img\n        self._image_zoom_win = win\n\n    def _render_document(self, doc):\n        \"\"\"Render text / OPML / image from text(base64) or bytes.\"\"\"\n        title, content = _extract_title_content(doc)\n        self._current_content = content\n\n        # OPML?\n        if isinstance(content, str) and self._looks_like_opml(content):\n            self._render_opml_outline(content)\n            self.status.set(f\"Viewing OPML: {title} (id={self.current_doc_id})\")\n            return\n\n        # Text mode\n        self._show_text_mode()\n        self.text.delete(\"1.0\", \"end\")\n        self._hide_image()\n\n        # Try Base64 (string)\n        if PIL_AVAILABLE and isinstance(content, str) and _looks_like_b64_text(content):\n            decoded = _decode_b64_text(content)\n            if decoded:\n                try:\n                    pil = Image.open(BytesIO(decoded))\n                    self._set_img_label(pil)\n                    self.status.set(\n                        f\"Viewing image (decoded from Base64 text): id={self.current_doc_id}, {_human_size(len(decoded))}\"\n                    )\n                    return\n                except Exception as e:\n                    print(\"Base64 text image render failed:\", e)\n\n        # Try bytes that are Base64 text\n        if (\n            PIL_AVAILABLE\n            and isinstance(content, (bytes, bytearray))\n            and _looks_like_b64_bytes(content)\n        ):\n            decoded = _decode_b64_bytes(content)\n            if decoded:\n                try:\n                    pil = Image.open(BytesIO(decoded))\n                    self._set_img_label(pil)\n                    self.status.set(\n                        f\"Viewing image (decoded from Base64 bytes): id={self.current_doc_id}, {_human_size(len(decoded))}\"\n                    )\n                    return\n                except Exception as e:\n                    print(\"Base64 bytes image render failed:\", e)\n\n        # Try raw image bytes\n        if PIL_AVAILABLE and isinstance(content, (bytes, bytearray)):\n            try:\n                pil = Image.open(BytesIO(content))\n                self._set_img_label(pil)\n                self.status.set(\n                    f\"Viewing image (BLOB): id={self.current_doc_id}, {_human_size(len(content))}\"\n                )\n                return\n            except Exception as e:\n                print(\"BLOB image render failed:\", e)\n\n        # Fallback: textual content\n        display = (\n            content\n            if isinstance(content, str)\n            else (\n                render_binary_as_text(content)\n                if render_binary_as_text and isinstance(content, (bytes, bytearray))\n                else str(content)\n            )\n        )\n        self.text.insert(\"1.0\", display)\n\n        # Parse links if available and content is textual\n        if parse_links and isinstance(display, str):\n            try:\n                parse_links(self.text, display, self._open_doc_id)\n            except Exception as e:\n                print(\"parse_links failed:\", e)\n\n        self.status.set(f\"Viewing: {title} (id={self.current_doc_id})\")\n\n    def _render_binary_preview(self, payload):\n        if render_binary_preview:\n            try:\n                render_binary_preview(self.text, payload)\n                return\n            except Exception as e:\n                print(\"render_binary_preview failed:\", e)\n        if render_binary_as_text:\n            try:\n                display = render_binary_as_text(self.text, payload)\n                self.text.insert(\"1.0\", display)\n            except Exception as e:\n                print(\"render_binary_as_text failed:\", e)\n\n    # ---------- Commands ----------\n    def _on_ask(self):\n        sel = self._get_selected_text()\n        if not sel.strip():\n            messagebox.showinfo(\"ASK\", \"Please select some text in the document first.\")\n            return\n\n        if not self.processor or not hasattr(self.processor, \"query_ai\"):\n            messagebox.showerror(\"ASK\", \"CommandProcessor.query_ai is unavailable.\")\n            return\n\n        current_id = self.current_doc_id\n        prefix = simpledialog.askstring(\n            \"ASK prefix\",\n            \"Enter prefix (optional):\",\n            initialvalue=\"Please expand on this: \",\n        )\n        if prefix is None:\n            return\n\n        def _on_success(new_id):\n            try:\n                messagebox.showinfo(\"ASK\", f\"Created new document {new_id}\")\n            finally:\n                self._refresh_index()\n\n        def _on_link_created(_t):\n            # Re-open current doc so green link appears immediately\n            if current_id is not None and self.doc_store:\n                try:\n                    doc = self.doc_store.get_document(current_id)\n                    if doc:\n                        self._render_document(doc)\n                except Exception as e:\n                    print(\"on_link_created refresh failed:\", e)\n\n        # Try 5-arg signature first, then legacy 4-arg\n        try:\n            self.processor.query_ai(\n                selected_text=sel,\n                current_doc_id=current_id,\n                on_success=_on_success,\n                on_link_created=_on_link_created,\n                prefix=prefix,\n            )\n        except TypeError:\n            try:\n                self.processor.query_ai(sel, current_id, _on_success, _on_link_created)\n            except Exception as e:\n                messagebox.showerror(\"ASK\", f\"query_ai failed: {e}\")\n        except Exception as e:\n            messagebox.showerror(\"ASK\", f\"query_ai error: {e}\")\n\n    def _go_back(self):\n        if not self.history:\n            messagebox.showinfo(\"Back\", \"No previous document.\")\n            return\n        prev = self.history.pop()\n        self._open_doc_id(prev)\n\n    def _open_by_id(self):\n        s = simpledialog.askstring(\"Open\", \"Document ID:\")\n        if not s:\n            return\n        self._open_doc_id(s)\n\n    def _import_directory(self):\n        from pathlib import Path\n        # Try preferred module-based importer first\n        import_fn = None\n        try:\n            from modules import directory_import\n            import_fn = getattr(directory_import, \"import_text_files_from_directory\", None)\n        except Exception:\n            import_fn = None\n\n        path = filedialog.askdirectory(title=\"Choose a directory to import\")\n        if not path:\n            return\n\n        if callable(import_fn):\n            try:\n                imported, skipped = import_fn(Path(path), self.doc_store, skip_existing=True)\n                messagebox.showinfo(\n                    \"Directory Import\",\n                    f\"Imported {imported} file(s), skipped {skipped} existing.\"\n                )\n                self._refresh_index()\n                return\n            except Exception as e:\n                messagebox.showerror(\"Directory Import\", f\"Import failed: {e}\")\n                return\n\n        # Fallback: try common CommandProcessor methods if the module isn't available\n        for name in (\"import_directory\", \"import_dir\", \"import_from_directory\"):\n            fn = getattr(self.processor, name, None)\n            if callable(fn):\n                try:\n                    try:\n                        added = fn(path)\n                    except TypeError:\n                        added = fn(directory=path)\n                    messagebox.showinfo(\"Directory Import\", f\"Imported {added}\")\n                    self._refresh_index()\n                    return\n                except Exception as e:\n                    messagebox.showerror(\"Directory Import\", f\"Import failed: {e}\")\n                    return\n\n        messagebox.showerror(\n            \"Directory Import\",\n            \"No usable entrypoint found. Expected modules.directory_import.import_text_files_from_directory(...) \"\n            \"or a CommandProcessor import method.\"\n        )\n\n    def _open_opml_from_file(self):\n        # Prefer plugin flow when available\n        if opml_plugin and hasattr(opml_plugin, \"open_opml_file_dialog\"):\n            try:\n                new_id = opml_plugin.open_opml_file_dialog(self)\n                if new_id:\n                    self._open_doc_id(new_id)\n                return\n            except Exception as e:\n                messagebox.showerror(\"OPML\", f\"Open OPML failed: {e}\")\n                return\n\n        # Fallback: let user pick a file and call into processor with any of the common names\n        filepath = filedialog.askopenfilename(\n            title=\"Open OPML file\",\n            filetypes=[(\"OPML files\", \"*.opml *.xml\"), (\"All files\", \"*.*\")],\n        )\n        if not filepath:\n            return\n\n        if not self.processor:\n            messagebox.showerror(\"OPML\", \"OPML feature unavailable (no processor).\")\n            return\n\n        # Try common import function names\n        func = None\n        for name in (\"import_opml_from_path\", \"import_opml\", \"import_opml_file\"):\n            func = getattr(self.processor, name, None)\n            if callable(func):\n                break\n\n        if not func:\n            messagebox.showerror(\n                \"OPML\", \"No OPML import function found in CommandProcessor.\"\n            )\n            return\n\n        try:\n            new_id = func(filepath)\n        except Exception as e:\n            messagebox.showerror(\"OPML\", f\"OPML import failed: {e}\")\n            return\n        if new_id:\n            self._open_doc_id(new_id)\n\n    def _convert_selection_to_opml(self):\n        if self._mode != \"text\":\n            messagebox.showinfo(\n                \"Convert \u2192 OPML\",\n                \"Switch to a text document and select text to convert.\",\n            )\n            return\n\n        sel = self._get_selected_text()\n        if not sel.strip():\n            messagebox.showinfo(\"Convert \u2192 OPML\", \"Select some text first.\")\n            return\n        # Prefer plugin conversion if present\n        xml_text = None\n        if opml_plugin:\n            conv = getattr(opml_plugin, \"convert_text_to_opml_inplace\", None)\n            if callable(conv):\n                try:\n                    xml_text = conv(sel)\n                except Exception as e:\n                    messagebox.showerror(\"Convert \u2192 OPML\", f\"Conversion failed: {e}\")\n                    return\n        if xml_text is None:\n            xml_text = self._basic_text_to_opml(sel)\n\n        win = tk.Toplevel(self)\n        win.title(\"OPML Preview\")\n        txt = tk.Text(win, wrap=\"word\")\n        txt.pack(fill=\"both\", expand=True)\n        txt.insert(\"1.0\", xml_text)\n\n        def _save():\n            out = filedialog.asksaveasfilename(\n                title=\"Save OPML\",\n                defaultextension=\".opml\",\n                filetypes=[\n                    (\"OPML files\", \"*.opml\"),\n                    (\"XML files\", \"*.xml\"),\n                    (\"All files\", \"*.*\"),\n                ],\n            )\n            if not out:\n                return\n            Path(out).write_text(xml_text, encoding=\"utf-8\")\n            messagebox.showinfo(\"OPML\", f\"Saved to {out}\")\n\n        ttk.Button(win, text=\"Save\u2026\", command=_save).pack(pady=6)\n\n    def _reparse_links(self):\n        \"\"\"Re-run link parsing on the current Text widget content (text mode only).\"\"\"\n        if self._mode != \"text\":\n            messagebox.showinfo(\n                \"Reparse Links\", \"Not applicable for OPML outline view.\"\n            )\n            return\n        if not parse_links:\n            messagebox.showinfo(\"Reparse Links\", \"No link parser available.\")\n            return\n        try:\n            current_text = self.text.get(\"1.0\", \"end-1c\")\n            self._current_content = current_text\n            parse_links(self.text, current_text, self._open_doc_id)\n            self.status.set(\"Links reparsed.\")\n        except Exception as e:\n            messagebox.showerror(\"Reparse Links\", f\"Failed: {e}\")\n\n    def _on_search_clicked(self):\n        q = simpledialog.askstring(\"Search\", \"Enter query (matches title/content):\")\n        if not q:\n            return\n        ql = q.lower()\n\n        rows = []\n        if self.doc_store and hasattr(self.doc_store, \"get_document_index\"):\n            try:\n                rows = self.doc_store.get_document_index() or []\n            except Exception as e:\n                print(\"get_document_index failed:\", e)\n\n        try:\n            self.sidebar.delete(*self.sidebar.get_children())\n        except Exception:\n            pass\n\n        for row in rows:\n            if isinstance(row, sqlite3.Row):\n                m = dict(row)\n                doc_id = m.get(\"id\", m.get(\"doc_id\", m.get(\"pk\", None)))\n                title = str(m.get(\"title\", m.get(\"name\", \"\")) or \"\")\n                content = (\n                    m.get(\"content\")\n                    or m.get(\"body\")\n                    or m.get(\"text\")\n                    or m.get(\"raw\")\n                    or m.get(\"data\")\n                    or m.get(\"value\")\n                    or m.get(\"description\")\n                    or \"\"\n                )\n            elif isinstance(row, dict):\n                doc_id = row.get(\"id\") or row.get(\"doc_id\") or row.get(\"pk\")\n                title = str(row.get(\"title\", row.get(\"name\", \"\")) or \"\")\n                content = (\n                    row.get(\"content\")\n                    or row.get(\"body\")\n                    or row.get(\"text\")\n                    or row.get(\"raw\")\n                    or row.get(\"data\")\n                    or row.get(\"value\")\n                    or row.get(\"description\")\n                    or \"\"\n                )\n            else:\n                doc_id = (\n                    row[0] if isinstance(row, (list, tuple)) and len(row) > 0 else None\n                )\n                title = (\n                    row[1]\n                    if isinstance(row, (list, tuple))\n                    and len(row) > 1\n                    and isinstance(row[1], str)\n                    else \"\"\n                )\n                content = (\n                    row[2] if isinstance(row, (list, tuple)) and len(row) > 2 else \"\"\n                )\n\n            hay = (_make_preview(title, content) + \"\\n\" + str(content)).lower()\n            if ql in hay:\n                size = self._approx_payload_size(content)\n                self.sidebar.insert(\n                    \"\",\n                    \"end\",\n                    values=(doc_id, _make_preview(title, content), _human_size(size)),\n                )\n\n    def _save_visible_text(self):\n        if self._mode != \"text\":\n            messagebox.showinfo(\"Save Visible Text\", \"Switch to a text document first.\")\n            return\n        visible = self.text.get(\"1.0\", \"end-1c\")\n        if not visible.strip():\n            messagebox.showinfo(\"Save Visible Text\", \"No text to save.\")\n            return\n        out = filedialog.asksaveasfilename(\n            title=\"Save Visible Text\",\n            defaultextension=\".txt\",\n            filetypes=[(\"Text\", \"*.txt\"), (\"All files\", \"*.*\")],\n        )\n        if not out:\n            return\n        Path(out).write_text(visible, encoding=\"utf-8\")\n        messagebox.showinfo(\"Saved\", f\"Saved to {out}\")\n\n    def _import_text_file(self):\n        path = filedialog.askopenfilename(\n            title=\"Import\", filetypes=[(\"Text\", \"*.txt\"), (\"All\", \"*.*\")]\n        )\n        if not path:\n            return\n        body = Path(path).read_text(encoding=\"utf-8\", errors=\"replace\")\n        title = Path(path).stem\n        nid = self.doc_store.add_document(title, body)\n        self._refresh_index()\n        doc = self.doc_store.get_document(nid)\n        if doc:\n            self._render_document(doc)\n\n    def _export_current(self):\n        if self.current_doc_id is None:\n            messagebox.showwarning(\"Export\", \"No document loaded.\")\n            return\n        doc = self.doc_store.get_document(self.current_doc_id)\n        if not doc:\n            messagebox.showerror(\"Export\", \"Not found.\")\n            return\n        title, content = _extract_title_content(doc)\n\n        # Choose extension\n        if isinstance(content, (bytes, bytearray)) or _looks_like_b64_text(\n            content if isinstance(content, str) else \"\"\n        ):\n            default_ext = \".png\"\n            types = [(\"PNG image\", \"*.png\"), (\"All files\", \"*.*\")]\n        elif isinstance(content, str) and self._looks_like_opml(content):\n            default_ext = \".opml\"\n            types = [(\"OPML\", \"*.opml\"), (\"XML\", \"*.xml\"), (\"All files\", \"*.*\")]\n        else:\n            default_ext = \".txt\"\n            types = [(\"Text\", \"*.txt\"), (\"All files\", \"*.*\")]\n\n        default_name = f\"document_{self.current_doc_id}{default_ext}\"\n        out = filedialog.asksaveasfilename(\n            title=\"Export Current\",\n            defaultextension=default_ext,\n            initialfile=default_name,\n            filetypes=types,\n        )\n        if not out:\n            return\n\n        try:\n            if isinstance(content, (bytes, bytearray)):\n                Path(out).write_bytes(content)\n            elif isinstance(content, str) and _looks_like_b64_text(content):\n                b = _decode_b64_text(content)\n                if b:\n                    Path(out).write_bytes(b)\n                else:\n                    Path(out).write_text(content, encoding=\"utf-8\")\n            else:\n                Path(out).write_text(str(content), encoding=\"utf-8\")\n            messagebox.showinfo(\"Export\", f\"Saved to:\\n{out}\")\n        except Exception as e:\n            messagebox.showerror(\"Export\", f\"Failed to save: {e}\")\n\n    def _export_and_launch_flask(self):\n        export_path = Path(\"exported_docs\")\n        export_path.mkdir(exist_ok=True)\n\n        # export simple JSON docs (best-effort)\n        try:\n            import json\n\n            if self.doc_store and hasattr(self.doc_store, \"get_document_index\"):\n                for row in self.doc_store.get_document_index() or []:\n                    doc_id = (\n                        row.get(\"id\")\n                        if isinstance(row, dict)\n                        else (row[0] if isinstance(row, (list, tuple)) else None)\n                    )\n                    if doc_id is None:\n                        continue\n                    doc = self.doc_store.get_document(doc_id)\n                    if isinstance(doc, sqlite3.Row):\n                        data = dict(doc)\n                    elif isinstance(doc, dict):\n                        data = dict(doc)\n                    elif isinstance(doc, (list, tuple)):\n                        data = {\n                            \"id\": doc[0] if len(doc) > 0 else None,\n                            \"title\": doc[1] if len(doc) > 1 else \"\",\n                            \"body\": doc[2] if len(doc) > 2 else \"\",\n                        }\n                    else:\n                        data = {\"id\": doc_id, \"title\": \"\", \"body\": str(doc)}\n                    with open(\n                        export_path / f\"{data.get('id')}.json\", \"w\", encoding=\"utf-8\"\n                    ) as f:\n                        json.dump(data, f, indent=2)\n        except Exception as e:\n            print(\"Export JSON failed:\", e)\n\n        # Launch Flask if present\n        try:\n            import subprocess, sys\n\n            if flask_server_path.exists():\n                subprocess.Popen([sys.executable, str(flask_server_path)])\n                messagebox.showinfo(\n                    \"Server Started\", \"Flask server launched at http://127.0.0.1:5050\"\n                )\n            else:\n                messagebox.showwarning(\"Flask\", \"modules/flask_server.py not found.\")\n        except Exception as e:\n            messagebox.showerror(\"Flask\", f\"Failed to launch: {e}\")\n\n    @staticmethod\n    def _basic_text_to_opml(text: str) -> str:\n        import html\n\n        body = \"\\n\".join(\n            f'<outline text=\"{html.escape(line)}\" />'\n            for line in text.splitlines()\n            if line.strip()\n        )\n        return (\n            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n            '<opml version=\"2.0\">\\n'\n            \"  <head><title>Converted</title></head>\\n\"\n            \"  <body>\\n\"\n            f\"{body}\\n\"\n            \"  </body>\\n\"\n            \"</opml>\\n\"\n        )\n\n\ndef main():\n    app = App()\n    app.mainloop()\n\n\nif __name__ == \"__main__\":\n    main()\n\n# --- Compatibility alias for old imports ---\nDemoKitGUI = App\n"
}