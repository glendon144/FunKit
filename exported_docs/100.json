{
  "id": 100,
  "title": "gui_tkinter_universal",
  "body": "# gui_tkinter.py \u2014 Universal, compatibility-hardened GUI for FunKit/DemoKit\n# Date: 2025-08-23 (regen)\n# Key features:\n# - Accepts legacy module names (cmdprocessor.py / hypertextparser.py)\n# - Accepts both 5-arg and legacy 4-arg CommandProcessor.query_ai()\n# - Works whether CommandProcessor class is named CommandProcessor or CmdProcessor\n# - Preserves selection for ASK; re-renders doc so green links appear immediately\n# - Adds \"Reparse Links\" command to rebuild clickable links in-place\n# - Tries multiple OPML import function names\n# - Provides compatibility alias: DemoKitGUI = App\n#\n# Install path: modules/gui_tkinter.py\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nimport tkinter as tk\nfrom tkinter import ttk, filedialog, simpledialog, messagebox\n\n# ---- Optional image support (Pillow) ----\ntry:\n    from PIL import Image, ImageTk  # type: ignore\n    PIL_AVAILABLE = True\nexcept Exception:\n    PIL_AVAILABLE = False\n\n# ---- Safe importer ----\ndef _try_import(modpath: str, name: str | None = None, default=None):\n    try:\n        mod = __import__(modpath, fromlist=[\"*\"])\n        return getattr(mod, name, mod) if name else mod\n    except Exception:\n        return default\n\n# ---- Primary module names ----\ncommand_processor_mod = _try_import(\"modules.command_processor\")\ndocument_store_mod    = _try_import(\"modules.document_store\")\nhypertext_parser_mod  = _try_import(\"modules.hypertext_parser\")\nrenderer_mod          = _try_import(\"modules.renderer\")\nopml_plugin           = _try_import(\"modules.opml_extras_plugin_v3\")\n\n# ---- Legacy/alternate module names (shims) ----\nif command_processor_mod is None:\n    command_processor_mod = _try_import(\"modules.cmdprocessor\")\nif hypertext_parser_mod is None:\n    hypertext_parser_mod = _try_import(\"modules.hypertextparser\")\n\n# Resolve CP class (CommandProcessor or CmdProcessor)\nCommandProcessor = None\nif command_processor_mod:\n    CommandProcessor = getattr(\n        command_processor_mod,\n        \"CommandProcessor\",\n        getattr(command_processor_mod, \"CmdProcessor\", None),\n    )\n\n# Resolve link parser function(s)\nparse_links = None\nif hypertext_parser_mod:\n    # common names first\n    for fname in (\"parse_links\", \"parse_links_v2\", \"reparse_links\"):\n        parse_links = getattr(hypertext_parser_mod, fname, None)\n        if callable(parse_links):\n            break\n\n# Optional renderer helpers\nrender_binary_preview = getattr(renderer_mod or object(), \"render_binary_preview\", None)\nrender_binary_as_text = getattr(renderer_mod or object(), \"render_binary_as_text\", None)\n\n\nclass App(tk.Tk):\n    \"\"\"\n    Universal GUI:\n      - Flexible constructor accepts legacy args/kwargs:\n          App(doc_store, processor, root)  # legacy style (extra args ignored)\n          App(doc_store=..., processor=...)  # preferred explicit kwargs\n          App()  # will self-initialize store & processor if modules present\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        # Accept legacy positional args: (doc_store, processor, root?) \u2014 we ignore root\n        doc_store_pos = args[0] if len(args) >= 1 else None\n        processor_pos = args[1] if len(args) >= 2 else None\n\n        super().__init__()\n        self.title(\"FunKit / DemoKit \u2014 GUI\")\n        self.geometry(\"1120x740\")\n\n        # Public state\n        self.current_doc_id: int | None = None\n        self.history: list[int] = []\n        self._last_selection: tuple[str, str] | None = None\n        self._current_content: str | bytes | None = None  # for Reparse Links\n\n        # Prefer explicit kwargs, else positional, else auto-init modules if available\n        self.doc_store = kwargs.get(\"doc_store\") or doc_store_pos\n        self.processor = kwargs.get(\"processor\") or processor_pos\n\n        if self.doc_store is None and document_store_mod and hasattr(document_store_mod, \"DocumentStore\"):\n            try:\n                self.doc_store = document_store_mod.DocumentStore()\n            except Exception as e:\n                print(\"Warning: DocumentStore failed to init:\", e)\n\n        if self.processor is None and CommandProcessor:\n            try:\n                self.processor = CommandProcessor()\n            except Exception as e:\n                print(\"Warning: CommandProcessor failed to init:\", e)\n\n        self._build_ui()\n        self._refresh_index()\n\n    # ---------- UI ----------\n    def _build_ui(self):\n        root = self\n\n        # Toolbar\n        bar = ttk.Frame(root)\n        bar.pack(side=\"top\", fill=\"x\")\n\n        ttk.Button(bar, text=\"Ask\", command=self._on_ask).pack(side=\"left\", padx=4, pady=4)\n        ttk.Button(bar, text=\"Back\", command=self._go_back).pack(side=\"left\", padx=4, pady=4)\n        ttk.Button(bar, text=\"Open by ID\", command=self._open_by_id).pack(side=\"left\", padx=4, pady=4)\n\n        ttk.Separator(bar, orient=\"vertical\").pack(side=\"left\", fill=\"y\", padx=6)\n\n        ttk.Button(bar, text=\"Import Dir\", command=self._import_directory).pack(side=\"left\", padx=4, pady=4)\n        ttk.Button(bar, text=\"Open OPML\", command=self._open_opml_from_file).pack(side=\"left\", padx=4, pady=4)\n        ttk.Button(bar, text=\"Convert \u2192 OPML\", command=self._convert_selection_to_opml).pack(side=\"left\", padx=4, pady=4)\n\n        ttk.Separator(bar, orient=\"vertical\").pack(side=\"left\", fill=\"y\", padx=6)\n\n        ttk.Button(bar, text=\"Search\", command=self._on_search_clicked).pack(side=\"left\", padx=4, pady=4)\n        ttk.Button(bar, text=\"Reparse Links\", command=self._reparse_links).pack(side=\"left\", padx=4, pady=4)\n\n        # Panes\n        self.panes = ttk.Panedwindow(root, orient=\"horizontal\")\n        self.panes.pack(fill=\"both\", expand=True)\n\n        # Left: index\n        left = ttk.Frame(self.panes)\n        self.sidebar = ttk.Treeview(left, columns=(\"id\", \"title\", \"extra\"), show=\"headings\", height=20)\n        self.sidebar.heading(\"id\", text=\"ID\")\n        self.sidebar.heading(\"title\", text=\"Title\")\n        self.sidebar.heading(\"extra\", text=\"\")\n        self.sidebar.column(\"id\", width=80, anchor=\"w\")\n        self.sidebar.column(\"title\", width=380, anchor=\"w\")\n        self.sidebar.column(\"extra\", width=60, anchor=\"center\")\n        self.sidebar.pack(fill=\"both\", expand=True)\n        self.sidebar.bind(\"<<TreeviewSelect>>\", self._on_sidebar_select)\n\n        left_bottom = ttk.Frame(left)\n        left_bottom.pack(fill=\"x\")\n        ttk.Button(left_bottom, text=\"Refresh\", command=self._refresh_index).pack(side=\"left\", padx=4, pady=4)\n        self.panes.add(left, weight=1)\n\n        # Right: document text\n        right = ttk.Frame(self.panes)\n        self.text = tk.Text(right, wrap=\"word\", undo=True)\n        yscroll = ttk.Scrollbar(right, orient=\"vertical\", command=self.text.yview)\n        self.text.configure(yscrollcommand=yscroll.set)\n        self.text.pack(side=\"left\", fill=\"both\", expand=True)\n        yscroll.pack(side=\"left\", fill=\"y\")\n\n        # Preserve selection for Ask\n        self.text.bind(\"<<Selection>>\", self._on_text_selection_changed)\n        self.text.bind(\"<ButtonRelease-1>\", self._on_text_selection_changed, add=\"+\")\n\n        self.panes.add(right, weight=3)\n\n        # Status\n        self.status = tk.StringVar(value=\"Ready\")\n        ttk.Label(root, textvariable=self.status, anchor=\"w\").pack(side=\"bottom\", fill=\"x\")\n\n        # Shortcuts\n        root.bind_all(\"<Control-Return>\", lambda e: self._on_ask())\n        root.bind_all(\"<Control-Shift-O>\", lambda e: self._convert_selection_to_opml())\n        root.bind_all(\"<Control-u>\", lambda e: self._open_opml_from_file())\n\n    # ---------- Selection handling ----------\n    def _on_text_selection_changed(self, event=None):\n        try:\n            start = self.text.index(\"sel.first\")\n            end = self.text.index(\"sel.last\")\n            self._last_selection = (start, end)\n        except Exception:\n            self._last_selection = None\n\n    def _get_selected_text(self) -> str:\n        try:\n            return self.text.get(\"sel.first\", \"sel.last\")\n        except Exception:\n            pass\n        if self._last_selection:\n            s, e = self._last_selection\n            try:\n                return self.text.get(s, e)\n            except Exception:\n                return \"\"\n        return \"\"\n\n    # ---------- Index / navigation ----------\n    def _refresh_index(self):\n        try:\n            self.sidebar.delete(*self.sidebar.get_children())\n        except Exception:\n            return\n\n        rows = []\n        if self.doc_store and hasattr(self.doc_store, \"get_document_index\"):\n            try:\n                rows = self.doc_store.get_document_index() or []\n            except Exception as e:\n                print(\"get_document_index failed:\", e)\n\n        for row in rows:\n            if isinstance(row, dict):\n                doc_id, title = row.get(\"id\"), row.get(\"title\", \"\")\n            elif isinstance(row, (list, tuple)):\n                doc_id, title = row[0], (row[1] if len(row) > 1 else \"\")\n            else:\n                continue\n            self.sidebar.insert(\"\", \"end\", values=(doc_id, title, \"\"))\n\n    def _on_sidebar_select(self, event=None):\n        sel = self.sidebar.selection()\n        if not sel:\n            return\n        item = self.sidebar.item(sel[0])\n        vals = item.get(\"values\") or []\n        if not vals:\n            return\n        doc_id = vals[0]\n        self._open_doc_id(doc_id)\n\n    def _open_doc_id(self, doc_id):\n        try:\n            doc_id = int(doc_id)\n        except Exception:\n            messagebox.showerror(\"Open\", f\"Invalid document id: {doc_id}\")\n            return\n\n        if self.current_doc_id is not None:\n            self.history.append(self.current_doc_id)\n\n        doc = None\n        if self.doc_store and hasattr(self.doc_store, \"get_document\"):\n            try:\n                doc = self.doc_store.get_document(doc_id)\n            except Exception as e:\n                print(\"get_document failed:\", e)\n        if not doc:\n            messagebox.showerror(\"Open\", f\"Document {doc_id} not found.\")\n            return\n\n        self.current_doc_id = doc_id\n        self._render_document(doc)\n\n    # ---------- Render ----------\n    def _render_document(self, doc):\n        self.text.delete(\"1.0\", \"end\")\n\n        content = \"\"\n        title = \"\"\n        if isinstance(doc, dict):\n            title = doc.get(\"title\", \"\")\n            content = doc.get(\"content\", \"\") or doc.get(\"body\", \"\") or \"\"\n        elif isinstance(doc, (list, tuple)):\n            title = doc[1] if len(doc) > 1 else \"\"\n            content = doc[2] if len(doc) > 2 else \"\"\n        else:\n            content = str(doc)\n\n        self._current_content = content  # save for Reparse Links\n\n        # Binary-as-image render path\n        if PIL_AVAILABLE and isinstance(content, (bytes, bytearray)):\n            try:\n                from io import BytesIO\n                im = Image.open(BytesIO(content))\n                imtk = ImageTk.PhotoImage(im)\n                self.text.image_create(\"end\", image=imtk)\n                self.text.insert(\"end\", \"\\n\")\n                if not hasattr(self, \"_img_refs\"):\n                    self._img_refs = []\n                self._img_refs.append(imtk)\n            except Exception:\n                self._render_binary_preview(content)\n        else:\n            # Text path\n            self.text.insert(\"1.0\", content)\n\n        # Parse links if available\n        if parse_links and isinstance(content, str):\n            try:\n                parse_links(self.text, content, self._open_doc_id)\n            except Exception as e:\n                print(\"parse_links failed:\", e)\n\n        self.status.set(f\"Viewing: {title} (id={self.current_doc_id})\")\n\n    def _render_binary_preview(self, payload):\n        if render_binary_preview:\n            try:\n                render_binary_preview(self.text, payload)\n                return\n            except Exception as e:\n                print(\"render_binary_preview failed:\", e)\n        if render_binary_as_text:\n            try:\n                render_binary_as_text(self.text, payload)\n            except Exception as e:\n                print(\"render_binary_as_text failed:\", e)\n\n    # ---------- Commands ----------\n    def _on_ask(self):\n        sel = self._get_selected_text()\n        if not sel.strip():\n            messagebox.showinfo(\"ASK\", \"Please select some text in the document first.\")\n            return\n\n        if not self.processor or not hasattr(self.processor, \"query_ai\"):\n            messagebox.showerror(\"ASK\", \"CommandProcessor.query_ai is unavailable.\")\n            return\n\n        current_id = self.current_doc_id\n        prefix = simpledialog.askstring(\n            \"ASK prefix\",\n            \"Enter prefix (optional):\",\n            initialvalue=\"Please expand on this: \"\n        )\n        if prefix is None:\n            return\n\n        def _on_success(new_id):\n            try:\n                messagebox.showinfo(\"ASK\", f\"Created new document {new_id}\")\n            finally:\n                self._refresh_index()\n\n        def _on_link_created(_t):\n            # Re-open current doc so green link appears immediately\n            if current_id is not None and self.doc_store:\n                try:\n                    doc = self.doc_store.get_document(current_id)\n                    if doc:\n                        self._render_document(doc)\n                except Exception as e:\n                    print(\"on_link_created refresh failed:\", e)\n\n        # Try 5-arg signature first, then legacy 4-arg\n        try:\n            self.processor.query_ai(\n                selected_text=sel,\n                current_doc_id=current_id,\n                on_success=_on_success,\n                on_link_created=_on_link_created,\n                prefix=prefix,\n            )\n        except TypeError:\n            try:\n                self.processor.query_ai(sel, current_id, _on_success, _on_link_created)\n            except Exception as e:\n                messagebox.showerror(\"ASK\", f\"query_ai failed: {e}\")\n        except Exception as e:\n            messagebox.showerror(\"ASK\", f\"query_ai error: {e}\")\n\n    def _go_back(self):\n        if not self.history:\n            messagebox.showinfo(\"Back\", \"No previous document.\")\n            return\n        prev = self.history.pop()\n        self._open_doc_id(prev)\n\n    def _open_by_id(self):\n        s = simpledialog.askstring(\"Open\", \"Document ID:\")\n        if not s:\n            return\n        self._open_doc_id(s)\n\n    def _import_directory(self):\n        if not self.processor or not hasattr(self.processor, \"import_directory\"):\n            messagebox.showerror(\"Import\", \"CommandProcessor.import_directory unavailable.\")\n            return\n        path = filedialog.askdirectory(title=\"Choose a directory to import\")\n        if not path:\n            return\n        try:\n            added = self.processor.import_directory(path)\n        except Exception as e:\n            messagebox.showerror(\"Import\", f\"Import failed: {e}\")\n            return\n        messagebox.showinfo(\"Import\", f\"Imported {added} documents.\")\n        self._refresh_index()\n\n    def _open_opml_from_file(self):\n        # Prefer plugin flow when available\n        if opml_plugin and hasattr(opml_plugin, \"open_opml_file_dialog\"):\n            try:\n                new_id = opml_plugin.open_opml_file_dialog(self)\n                if new_id:\n                    self._open_doc_id(new_id)\n                return\n            except Exception as e:\n                messagebox.showerror(\"OPML\", f\"Open OPML failed: {e}\")\n                return\n\n        # Fallback: let user pick a file and call into processor with any of the common names\n        filepath = filedialog.askopenfilename(\n            title=\"Open OPML file\",\n            filetypes=[(\"OPML files\", \"*.opml *.xml\"), (\"All files\", \"*.*\")]\n        )\n        if not filepath:\n            return\n\n        if not self.processor:\n            messagebox.showerror(\"OPML\", \"OPML feature unavailable (no processor).\")\n            return\n\n        # Try common import function names\n        func = None\n        for name in (\"import_opml_from_path\", \"import_opml\", \"import_opml_file\"):\n            func = getattr(self.processor, name, None)\n            if callable(func):\n                break\n\n        if not func:\n            messagebox.showerror(\"OPML\", \"No OPML import function found in CommandProcessor.\")\n            return\n\n        try:\n            new_id = func(filepath)\n        except Exception as e:\n            messagebox.showerror(\"OPML\", f\"OPML import failed: {e}\")\n            return\n        if new_id:\n            self._open_doc_id(new_id)\n\n    def _convert_selection_to_opml(self):\n        sel = self._get_selected_text()\n        if not sel.strip():\n            messagebox.showinfo(\"Convert \u2192 OPML\", \"Select some text first.\")\n            return\n        # Prefer plugin conversion if present\n        xml_text = None\n        if opml_plugin:\n            conv = getattr(opml_plugin, \"convert_text_to_opml_inplace\", None)\n            if callable(conv):\n                try:\n                    xml_text = conv(sel)\n                except Exception as e:\n                    messagebox.showerror(\"Convert \u2192 OPML\", f\"Conversion failed: {e}\")\n                    return\n        if xml_text is None:\n            xml_text = self._basic_text_to_opml(sel)\n\n        win = tk.Toplevel(self)\n        win.title(\"OPML Preview\")\n        txt = tk.Text(win, wrap=\"word\")\n        txt.pack(fill=\"both\", expand=True)\n        txt.insert(\"1.0\", xml_text)\n\n        def _save():\n            out = filedialog.asksaveasfilename(\n                title=\"Save OPML\",\n                defaultextension=\".opml\",\n                filetypes=[(\"OPML files\", \"*.opml\"), (\"XML files\", \"*.xml\"), (\"All files\", \"*.*\")]\n            )\n            if not out:\n                return\n            Path(out).write_text(xml_text, encoding=\"utf-8\")\n            messagebox.showinfo(\"OPML\", f\"Saved to {out}\")\n\n        ttk.Button(win, text=\"Save\u2026\", command=_save).pack(pady=6)\n\n    def _reparse_links(self):\n        \"\"\"Re-run link parsing on the current Text widget content.\"\"\"\n        if not parse_links:\n            messagebox.showinfo(\"Reparse Links\", \"No link parser available.\")\n            return\n        try:\n            # Get current visible content (may include edits)\n            current_text = self.text.get(\"1.0\", \"end-1c\")\n            self._current_content = current_text  # keep in sync\n            parse_links(self.text, current_text, self._open_doc_id)\n            self.status.set(\"Links reparsed.\")\n        except Exception as e:\n            messagebox.showerror(\"Reparse Links\", f\"Failed: {e}\")\n\n    @staticmethod\n    def _basic_text_to_opml(text: str) -> str:\n        import html\n        body = \"\\n\".join(\n            f'<outline text=\"{html.escape(line)}\" />'\n            for line in text.splitlines() if line.strip()\n        )\n        return (\n            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n            '<opml version=\"2.0\">\\n'\n            '  <head><title>Converted</title></head>\\n'\n            '  <body>\\n'\n            f'{body}\\n'\n            '  </body>\\n'\n            '</opml>\\n'\n        )\n\ndef main():\n    app = App()\n    app.mainloop()\n\nif __name__ == \"__main__\":\n    main()\n\n# --- Compatibility alias for old imports ---\nDemoKitGUI = App\n"
}