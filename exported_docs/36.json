{
  "id": 36,
  "title": "TreeView-pre-opml",
  "body": "# modules/TreeView.py\n# FunKit Document Tree viewer (standalone Tk widget)\n# - Show IDs toggle\n# - Quick-jump by ID (accepts \"1\", \"Doc 1\", \"Document 1\", etc.)\n# - Lazy-loading children\n# - Fallback: when no ancestry is available, Jump opens doc directly\n#\n# Integration sketch (in your GUI):\n#   from modules.TreeView import open_tree_view\n#   open_tree_view(root, repo=YourRepo(db_path),\n#                  on_open_doc=self._on_link_click,\n#                  root_doc_id=current_doc_id)\n\nfrom __future__ import annotations\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nfrom dataclasses import dataclass\nfrom typing import Optional, Callable, Iterable, List, Dict, Any\nimport re\n\n# ----------------------------\n# Data model contracts\n# ----------------------------\n\n@dataclass\nclass DocNode:\n    id: int\n    title: str\n    parent_id: Optional[int]  # None if a root\n    created_at: Optional[str] = None  # optional extras\n\nclass RepoProtocol:\n    \"\"\"\n    Minimal repo interface TreeView needs. Plug your SQLite/doc layer here.\n    \"\"\"\n    def get_doc(self, doc_id: int) -> Optional[DocNode]:\n        raise NotImplementedError\n\n    def get_children(self, parent_id: Optional[int]) -> Iterable[DocNode]:\n        \"\"\"\n        Return children ordered as you like (e.g., created_at asc).\n        If parent_id is None, return top-level roots.\n        \"\"\"\n        raise NotImplementedError\n\n\n# ----------------------------\n# TreeView implementation\n# ----------------------------\n\nclass TreeViewWindow(tk.Toplevel):\n    def __init__(\n        self,\n        master: tk.Misc,\n        repo: RepoProtocol,\n        on_open_doc: Callable[[int], None],\n        root_doc_id: Optional[int] = None,\n        title: str = \"FunKit Document Tree\",\n    ):\n        super().__init__(master)\n        self.title(title)\n        self.geometry(\"640x520\")\n        self.minsize(480, 360)\n\n        self.repo = repo\n        self.on_open_doc = on_open_doc\n        self.root_doc_id = root_doc_id\n\n        # State\n        self.show_ids_var = tk.BooleanVar(value=True)\n        self._loaded_children: Dict[str, bool] = {}  # item_id -> loaded?\n        self._iid_to_id: Dict[str, int] = {}         # item_id -> doc_id\n\n        # UI\n        self._build_toolbar()\n        self._build_tree()\n        self._build_statusbar()\n\n        self.protocol(\"WM_DELETE_WINDOW\", self._on_close)\n        self.bind(\"<Escape>\", lambda e: self.destroy())\n\n        self._populate_initial()\n\n    # ---------- UI Construction ----------\n\n    def _build_toolbar(self):\n        bar = ttk.Frame(self)\n        bar.pack(side=tk.TOP, fill=tk.X, padx=8, pady=6)\n\n        ttk.Label(bar, text=\"Quick-Jump ID:\").pack(side=tk.LEFT)\n        self.jump_entry = ttk.Entry(bar, width=16)\n        self.jump_entry.pack(side=tk.LEFT, padx=(4, 8))\n        self.jump_entry.bind(\"<Return>\", self._on_jump)\n\n        ttk.Button(bar, text=\"Jump\", command=self._on_jump).pack(side=tk.LEFT, padx=(0, 12))\n        ttk.Checkbutton(bar, text=\"Show IDs\", variable=self.show_ids_var, command=self._refresh_labels)\\\n            .pack(side=tk.LEFT)\n\n        ttk.Separator(bar, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=10)\n\n        ttk.Button(bar, text=\"Expand All\", command=self._expand_all).pack(side=tk.LEFT)\n        ttk.Button(bar, text=\"Collapse All\", command=self._collapse_all).pack(side=tk.LEFT, padx=(6, 0))\n\n    def _build_tree(self):\n        container = ttk.Frame(self)\n        container.pack(fill=tk.BOTH, expand=True, padx=8, pady=(0, 8))\n\n        self.tree = ttk.Treeview(container, show=\"tree\")\n        vsb = ttk.Scrollbar(container, orient=\"vertical\", command=self.tree.yview)\n        hsb = ttk.Scrollbar(container, orient=\"horizontal\", command=self.tree.xview)\n        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)\n\n        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        vsb.pack(side=tk.RIGHT, fill=tk.Y)\n        hsb.pack(side=tk.BOTTOM, fill=tk.X)\n\n        self.tree.bind(\"<<TreeviewOpen>>\", self._on_open_node)\n        self.tree.bind(\"<Double-1>\", self._on_double_click)\n        self.tree.bind(\"<Return>\", self._on_open_selected)\n\n        # Style tweak\n        style = ttk.Style(self)\n        try:\n            style.configure(\"Treeview\", rowheight=22)\n        except tk.TclError:\n            pass\n\n    def _build_statusbar(self):\n        self.status = tk.StringVar(value=\"Ready\")\n        bar = ttk.Frame(self)\n        bar.pack(side=tk.BOTTOM, fill=tk.X)\n        ttk.Label(bar, textvariable=self.status, anchor=\"w\").pack(side=tk.LEFT, padx=8, pady=4)\n\n    # ---------- Data Population ----------\n\n    def _populate_initial(self):\n        self.tree.delete(*self.tree.get_children(\"\"))\n        self._loaded_children.clear()\n        self._iid_to_id.clear()\n\n        if self.root_doc_id is not None:\n            root_doc = self.repo.get_doc(self.root_doc_id)\n            if not root_doc:\n                self._set_status(f\"Root doc {self.root_doc_id} not found. Showing all roots.\")\n                self._populate_roots()\n                return\n            root_iid = self._insert_doc(\"\", root_doc)\n            self._insert_placeholder(root_iid)  # lazy-load children\n            self.tree.item(root_iid, open=True)\n            self._set_status(f\"Root: {self._label_for(root_doc)}\")\n        else:\n            self._populate_roots()\n\n    def _populate_roots(self):\n        roots = list(self.repo.get_children(None))\n        if not roots:\n            self._set_status(\"No root documents found.\")\n            return\n        for d in roots:\n            iid = self._insert_doc(\"\", d)\n            self._insert_placeholder(iid)\n        self._set_status(f\"Loaded {len(roots)} roots.\")\n\n    # ---------- Tree Helpers ----------\n\n    def _insert_doc(self, parent_iid: str, doc: DocNode) -> str:\n        label = self._label_for(doc)\n        iid = self.tree.insert(parent_iid, \"end\", text=label)\n        self.tree.item(iid, open=False)\n        try:\n            self._iid_to_id[iid] = int(doc.id)\n        except Exception:\n            pass\n        return iid\n\n    def _insert_placeholder(self, iid: str):\n        # Placeholder child signifies \u201cexpand to load\u201d\n        self.tree.insert(iid, \"end\", text=\"\u2026\")\n        self._loaded_children[iid] = False\n\n    def _load_children_if_needed(self, iid: str):\n        if self._loaded_children.get(iid, True):\n            return\n        # Clear placeholder(s)\n        for child in self.tree.get_children(iid):\n            self.tree.delete(child)\n        # Load actual children\n        doc_id = self._doc_id_for_iid(iid)\n        if doc_id is None:\n            self._loaded_children[iid] = True\n            return\n        kids = list(self.repo.get_children(doc_id))\n        for d in kids:\n            kid_iid = self._insert_doc(iid, d)\n            self._insert_placeholder(kid_iid)\n        self._loaded_children[iid] = True\n\n    def _label_for(self, doc: DocNode) -> str:\n        title = (doc.title or \"\").strip() or \"(untitled)\"\n        return f\"{doc.id}: {title}\" if self.show_ids_var.get() else title\n\n    def _doc_id_for_iid(self, iid: str) -> Optional[int]:\n        return self._iid_to_id.get(iid)\n\n    def _refresh_labels(self):\n        # Re-render row labels to show/hide IDs\n        def walk(parent=\"\"):\n            for iid in self.tree.get_children(parent):\n                doc_id = self._doc_id_for_iid(iid)\n                if doc_id is not None:\n                    doc = self.repo.get_doc(doc_id)\n                    if doc:\n                        label = self._label_for(doc)\n                        self.tree.item(iid, text=label)\n                walk(iid)\n        walk()\n        self._set_status(\"Toggled Show IDs.\")\n\n    # ---------- Events ----------\n\n    def _on_open_node(self, event=None):\n        sel = self.tree.focus()\n        if sel:\n            self._load_children_if_needed(sel)\n\n    def _on_double_click(self, event=None):\n        self._on_open_selected()\n\n    def _on_open_selected(self, event=None):\n        sel = self.tree.focus()\n        if not sel:\n            return\n        doc_id = self._doc_id_for_iid(sel)\n        if doc_id is None:\n            return\n        try:\n            self.on_open_doc(doc_id)\n            self._set_status(f\"Opened doc {doc_id}.\")\n        except Exception as e:\n            messagebox.showerror(\"Open Document Error\", str(e))\n\n    def _on_jump(self, event=None):\n        raw = self.jump_entry.get().strip()\n        m = re.search(r\"\\d+\", raw)\n        if not m:\n            self._set_status(\"Enter a numeric ID.\")\n            return\n        target_id = int(m.group(0))\n        self._jump_to_doc(target_id)\n\n    # ---------- Jump / Find ----------\n\n    def _jump_to_doc(self, doc_id: int):\n        # Try visible first\n        found = self._find_visible_iid(doc_id)\n        if found:\n            self._focus_and_reveal(found)\n            return\n\n        # Try to compute an ancestor chain (works if parent_id is available)\n        path = self._compute_ancestor_chain(doc_id)\n        if not path:\n            # Fallback: open the doc directly via the host callback\n            try:\n                self.on_open_doc(doc_id)\n                self._set_status(f\"Opened doc {doc_id} (no ancestry available).\")\n            except Exception:\n                self._set_status(f\"Document {doc_id} not found.\")\n            return\n\n        # Materialize and expand the path\n        parent_iid = \"\"\n        if self.root_doc_id is not None:\n            top = self.tree.get_children(\"\")\n            if not top:\n                self._set_status(\"Tree is empty.\")\n                return\n            parent_iid = top[0]\n\n        for ancestor_id in path:\n            iid = self._ensure_child_item(parent_iid, ancestor_id)\n            self.tree.item(iid, open=True)\n            self._load_children_if_needed(iid)\n            parent_iid = iid\n\n        target_iid = self._ensure_child_item(parent_iid, doc_id)\n        self._focus_and_reveal(target_iid)\n\n    def _ensure_child_item(self, parent_iid: str, child_doc_id: int) -> str:\n        # Try to find an existing child for this ID under parent_iid; else insert it.\n        for iid in self.tree.get_children(parent_iid):\n            if self._doc_id_for_iid(iid) == child_doc_id:\n                return iid\n        # Need to insert it (fetch doc)\n        doc = self.repo.get_doc(child_doc_id)\n        if not doc:\n            # Create a stub for visibility\n            doc = DocNode(id=child_doc_id, title=\"(missing)\", parent_id=None)\n        iid = self._insert_doc(parent_iid, doc)\n        self._insert_placeholder(iid)\n        return iid\n\n    def _find_visible_iid(self, doc_id: int) -> Optional[str]:\n        def walk(parent=\"\") -> Optional[str]:\n            for iid in self.tree.get_children(parent):\n                if self._doc_id_for_iid(iid) == doc_id:\n                    return iid\n                found = walk(iid)\n                if found:\n                    return found\n            return None\n        return walk(\"\")\n\n    def _compute_ancestor_chain(self, doc_id: int) -> List[int]:\n        \"\"\"\n        Returns ancestors from the first ancestor under the current root to the parent of doc_id.\n        If the view is global (no root_doc_id), this returns the full chain from a root.\n        Requires a real parent_id chain; if your repo doesn't provide it, this returns [].\n        \"\"\"\n        chain: List[int] = []\n        cur = self.repo.get_doc(doc_id)\n        if not cur:\n            return []\n        # Walk explicit parent pointers; if your repo doesn't set them, this will no-op.\n        while cur and cur.parent_id is not None:\n            chain.append(cur.parent_id)\n            cur = self.repo.get_doc(cur.parent_id)\n        chain.reverse()\n        # If we are in single-root mode, trim any ancestors above root_doc_id\n        if self.root_doc_id is not None and chain and chain[0] != self.root_doc_id:\n            if self.root_doc_id in chain:\n                idx = chain.index(self.root_doc_id)\n                chain = chain[idx:]  # include root\n            else:\n                return []\n        return chain\n\n    def _focus_and_reveal(self, iid: str):\n        self.tree.see(iid)\n        self.tree.selection_set(iid)\n        self.tree.focus(iid)\n        # The #0 column holds text; use item text for status\n        label = self.tree.item(iid, \"text\")\n        self._set_status(f\"Jumped to {label}\")\n\n    # ---------- Expand/Collapse ----------\n\n    def _expand_all(self):\n        def walk(parent=\"\"):\n            for iid in self.tree.get_children(parent):\n                self._load_children_if_needed(iid)\n                self.tree.item(iid, open=True)\n                walk(iid)\n        walk()\n        self._set_status(\"Expanded all.\")\n\n    def _collapse_all(self):\n        def walk(parent=\"\"):\n            for iid in self.tree.get_children(parent):\n                self.tree.item(iid, open=False)\n                walk(iid)\n        walk()\n        self._set_status(\"Collapsed all.\")\n\n    # ---------- Misc ----------\n\n    def _set_status(self, msg: str):\n        self.status.set(msg)\n\n    def _on_close(self):\n        self.destroy()\n\n\n# ----------------------------\n# Public API\n# ----------------------------\n\ndef open_tree_view(\n    master: tk.Misc,\n    repo: RepoProtocol,\n    on_open_doc: Callable[[int], None],\n    root_doc_id: Optional[int] = None,\n    title: str = \"FunKit Document Tree\",\n) -> TreeViewWindow:\n    \"\"\"\n    Open the TreeView window. Keep a reference if you want to call methods later.\n    \"\"\"\n    win = TreeViewWindow(master, repo=repo, on_open_doc=on_open_doc, root_doc_id=root_doc_id, title=title)\n    win.transient(master)\n    win.grab_set()  # modal-ish; remove if you prefer modeless\n    return win\n\n\n# ----------------------------\n# Optional: Tiny demo harness\n#   Run `python -m modules.TreeView` to test with fake data.\n# ----------------------------\nif __name__ == \"__main__\":\n    class MemoryRepo(RepoProtocol):\n        def __init__(self, nodes: Dict[int, DocNode]):\n            self.nodes = nodes\n            self.children: Dict[Optional[int], List[DocNode]] = {}\n            for n in nodes.values():\n                self.children.setdefault(n.parent_id, []).append(n)\n            for k in self.children:\n                self.children[k].sort(key=lambda d: (d.parent_id is not None, d.id))\n\n        def get_doc(self, doc_id: int) -> Optional[DocNode]:\n            return self.nodes.get(doc_id)\n\n        def get_children(self, parent_id: Optional[int]) -> Iterable[DocNode]:\n            return list(self.children.get(parent_id, []))\n\n    nodes = {\n        1: DocNode(1, \"Root A\", None),\n        2: DocNode(2, \"Root B\", None),\n        3: DocNode(3, \"A.1\", 1),\n        4: DocNode(4, \"A.2\", 1),\n        5: DocNode(5, \"A.1.a\", 3),\n        6: DocNode(6, \"B.1\", 2),\n        7: DocNode(7, \"B.1.a\", 6),\n    }\n\n    def on_open(doc_id: int):\n        print(f\"OPEN {doc_id}\")\n\n    root = tk.Tk()\n    root.withdraw()\n    open_tree_view(root, repo=MemoryRepo(nodes), on_open_doc=on_open, root_doc_id=None)\n    root.mainloop()\n\n"
}