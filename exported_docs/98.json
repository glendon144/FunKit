{
  "id": 98,
  "title": "gui_tkinter_opml_works",
  "body": "import os\nimport threading\nimport tkinter as tk\nfrom tkinter import ttk, filedialog, simpledialog, messagebox\nfrom pathlib import Path\nfrom modules.renderer import render_binary_as_text\nfrom PIL import ImageTk, Image\nfrom modules import hypertext_parser, image_generator, document_store\nfrom modules.logger import Logger\nfrom tkinter import filedialog, messagebox\nfrom modules.directory_import import import_text_files_from_directory\nfrom modules.TreeView import open_tree_view\nimport subprocess\nimport sys\nimport json\nimport re  # for parsing (doc:ID) links\n\nSETTINGS_FILE = Path(\"funkit_settings.json\")\n\n\nclass DemoKitGUI(tk.Tk):\n    \"\"\"DemoKit GUI \u2013 ASK / IMAGE / BACK buttons, context menu, image overlay, and history.\"\"\"\n\n    def _looks_like_image(self, title: str) -> bool:\n        return title.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp'))\n\n    def _show_image_bytes(self, raw: bytes):\n        from io import BytesIO\n        pil = Image.open(BytesIO(raw))\n        w, h = max(100, self.winfo_width()-40), max(100, self.winfo_height()-40)\n        pil.thumbnail((w, h))\n        self._tk_img = ImageTk.PhotoImage(pil)\n        if not hasattr(self, '_img_label'):\n            self._img_label = tk.Label(self, bg='black')\n        self._img_label.configure(image=self._tk_img)\n        if self.text.winfo_manager():\n            self.text.pack_forget()\n        self._img_label.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n\n    def _hide_image(self):\n        if hasattr(self, '_img_label') and self._img_label.winfo_manager():\n            self._img_label.pack_forget()\n        if not self.text.winfo_manager():\n            self.text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n\n    SIDEBAR_WIDTH = 320\n\n    def __init__(self, doc_store, processor):\n        super().__init__()\n        self.doc_store = doc_store\n        self.processor = processor\n        self.logger: Logger = getattr(processor, \"logger\", Logger())\n        self.current_doc_id: int | None = None\n        self.history: list[int] = []\n\n        self._last_pil_img: Image.Image | None = None\n        self._last_tk_img: ImageTk.PhotoImage | None = None\n        self._image_enlarged: bool = False\n\n        # ---- Settings ----\n        self.settings = self._load_settings()\n        self.opml_expand_depth: int = int(self.settings.get(\"opml_expand_depth\", 2))\n\n        self.title(\"Engelbart Journal \u2013 DemoKit\")\n        self.geometry(\"1200x800\")\n        self.columnconfigure(0, minsize=self.SIDEBAR_WIDTH, weight=0)\n        self.columnconfigure(1, weight=1)\n        self.rowconfigure(0, weight=1)\n\n        self._build_sidebar()\n        self._build_main_pane()\n        self._build_context_menu()\n\n        # --- Menubar ---\n        menubar = tk.Menu(self)\n        # File menu\n        filemenu = tk.Menu(menubar, tearoff=0)\n        filemenu.add_command(label=\"Import\", command=self._import_doc)\n        filemenu.add_command(label=\"Export Current\", command=self._export_doc)\n        filemenu.add_separator()\n        filemenu.add_command(label=\"Export to Intraweb\", command=self.export_and_launch_server)\n        filemenu.add_separator()\n        filemenu.add_command(label=\"Quit\", command=self.destroy)\n        menubar.add_cascade(label=\"File\", menu=filemenu)\n        # View menu (adds TreeView entry + shortcut)\n        viewmenu = tk.Menu(menubar, tearoff=0)\n        viewmenu.add_command(label=\"Document Tree\\tCtrl+T\", command=self.on_tree_button)\n        viewmenu.add_separator()\n        viewmenu.add_command(label=\"Set OPML Expand Depth\u2026\", command=self._set_opml_expand_depth)\n        menubar.add_cascade(label=\"View\", menu=viewmenu)\n        self.config(menu=menubar)\n        # Keyboard shortcut\n        self.bind(\"<Control-t>\", lambda e: self.on_tree_button())\n\n        self._refresh_sidebar()\n\n    def _load_settings(self) -> dict:\n        try:\n            if SETTINGS_FILE.exists():\n                return json.loads(SETTINGS_FILE.read_text(encoding=\"utf-8\"))\n        except Exception:\n            pass\n        return {}\n\n    def _save_settings(self):\n        try:\n            SETTINGS_FILE.write_text(json.dumps(self.settings, indent=2), encoding=\"utf-8\")\n        except Exception as e:\n            print(\"[WARN] Could not save settings:\", e)\n\n    def _set_opml_expand_depth(self):\n        val = simpledialog.askinteger(\"OPML Expand Depth\",\n                                      \"Expand OPML to depth (0=root, 1=children, 2=grandchildren\u2026):\",\n                                      initialvalue=self.opml_expand_depth,\n                                      minvalue=0, maxvalue=99)\n        if val is None:\n            return\n        self.opml_expand_depth = int(val)\n        self.settings[\"opml_expand_depth\"] = self.opml_expand_depth\n        self._save_settings()\n        # If a Tree window with OPML loaded is open, apply immediately\n        win = getattr(self, \"tree_win\", None)\n        if win and win.winfo_exists():\n            self._apply_opml_expand_depth()\n\n    def _handle_strings(self):\n        doc_id = self.current_doc_id\n        if doc_id is None:\n            return\n        self._render_document(doc_id)\n\n    def _build_sidebar(self):\n        frame = tk.Frame(self)\n        frame.grid(row=0, column=0, sticky=\"nswe\")\n        self.sidebar = ttk.Treeview(frame, columns=(\"ID\",\"Title\",\"Description\"), show=\"headings\")\n        for col,w in ((\"ID\",60),(\"Title\",120),(\"Description\",160)):\n            self.sidebar.heading(col, text=col)\n            self.sidebar.column(col, width=w, anchor=\"w\", stretch=(col==\"Description\"))\n        self.sidebar.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        ttk.Scrollbar(frame, orient=\"vertical\", command=self.sidebar.yview).pack(side=tk.RIGHT, fill=tk.Y)\n        self.sidebar.bind(\"<<TreeviewSelect>>\", self._on_select)\n        self.sidebar.bind(\"<Delete>\", lambda e: self._on_delete_clicked())\n\n    def _on_select(self, event):\n        sel = self.sidebar.selection()\n        if not sel:\n            return\n        item = self.sidebar.item(sel[0])\n        try:\n            nid = int(item[\"values\"][0])\n        except (ValueError,TypeError):\n            return\n        if self.current_doc_id is not None:\n            self.history.append(self.current_doc_id)\n        self.current_doc_id = nid\n        doc = self.doc_store.get_document(nid)\n        if doc:\n            self._render_document(doc)\n\n    # keep delete handler above main pane to avoid edge cases\n    def _on_delete_clicked(self):\n        \"\"\"Delete the currently selected document.\"\"\"\n        sel = self.sidebar.selection()\n        if not sel:\n            messagebox.showwarning(\"Delete\", \"No document selected.\")\n            return\n        item = self.sidebar.item(sel[0])\n        try:\n            nid = int(item[\"values\"][0])\n        except (ValueError, TypeError):\n            messagebox.showerror(\"Delete\", \"Invalid document ID.\")\n            return\n        if not messagebox.askyesno(\"Confirm Delete\", f\"Delete document ID {nid}?\"):\n            return\n        doc = self.doc_store.get_document(nid)\n        self.doc_store.delete_document(nid)\n        self._refresh_sidebar()\n        self.text.delete(\"1.0\", tk.END)\n        self.img_label.configure(image=\"\")\n        self.current_doc_id = None\n        self._last_pil_img = None\n        self._last_tk_img = None\n        self._image_enlarged = False\n        messagebox.showinfo(\"Deleted\", f\"Document {nid} has been deleted.\")\n\n    def _build_main_pane(self):\n        pane = tk.Frame(self)\n        pane.grid(row=0, column=1, sticky=\"nswe\", padx=4, pady=4)\n        pane.rowconfigure(0, weight=3)\n        pane.rowconfigure(1, weight=1)\n        pane.columnconfigure(0, weight=1)\n\n        self.text = tk.Text(pane, wrap=\"word\")\n        self.text.grid(row=0, column=0, sticky=\"nswe\")\n        self.text.tag_configure(\"link\", foreground=\"green\", underline=True)\n        self.text.bind(\"<Button-3>\", self._show_context_menu)\n        self.text.bind(\"<Delete>\", lambda e: self._on_delete_clicked())\n\n        self.img_label = tk.Label(pane)\n        self.img_label.grid(row=1, column=0, sticky=\"ew\", pady=(8,0))\n        self.img_label.bind(\"<Button-1>\", lambda e: self._toggle_image())\n\n        btns = tk.Frame(pane)\n        btns.grid(row=2, column=0, sticky=\"we\", pady=(6,0))\n        acts = [\n            (\"TREE\", self.on_tree_button),\n            (\"OPEN OPML\", self._open_opml_from_main),\n            (\"ASK\", self._handle_ask),\n            (\"BACK\", self._go_back),\n            (\"DELETE\", lambda: self._on_delete_clicked()),\n            (\"IMAGE\", self._handle_image),\n            (\"FLASK\", self.export_and_launch_server),\n            (\"DIR IMPORT\", self._import_directory),\n            (\"SAVE AS TEXT\", self._save_binary_as_text),\n        ]\n        for i,(lbl,cmd) in enumerate(acts):\n            ttk.Button(btns, text=lbl, command=cmd).grid(row=0, column=i, sticky=\"we\", padx=(0,4))\n\n    def _build_context_menu(self):\n        self.context_menu = tk.Menu(self, tearoff=0)\n        self.context_menu.add_command(label=\"ASK\", command=self._handle_ask)\n        self.context_menu.add_command(label=\"Delete\", command=self._on_delete_clicked)\n        self.context_menu.add_separator()\n        self.context_menu.add_command(label=\"Import\", command=self._import_doc)\n        self.context_menu.add_command(label=\"Export\", command=self._export_doc)\n        self.context_menu.add_command(label=\"Save Binary As Text\", command=self._save_binary_as_text)\n\n    def _show_context_menu(self, event):\n        try:\n            self.context_menu.tk_popup(event.x_root, event.y_root)\n        finally:\n            self.context_menu.grab_release()\n\n    def _handle_ask(self):\n        try:\n            start = self.text.index(tk.SEL_FIRST)\n            end   = self.text.index(tk.SEL_LAST)\n            selected_text = self.text.get(start, end)\n        except tk.TclError:\n            messagebox.showwarning(\"ASK\",\"Please select some text first.\")\n            return\n        cid = self.current_doc_id\n        def on_success(nid):\n            messagebox.showinfo(\"ASK\",f\"Created new document {nid}.\")\n            self._refresh_sidebar()\n            # replace selection with link\n            self.text.delete(start,end)\n            link_md = f\"[{selected_text}](doc:{nid})\"\n            self.text.insert(start, link_md)\n            full = self.text.get(\"1.0\",tk.END)\n            # ---- if body is bytes and not an image, show placeholder instead of parsing ----\n            doc = self.doc_store.get_document(nid)\n            if isinstance(doc[\"body\"], bytes):\n                self.text.insert(tk.END, \"[binary document]\")\n                return\n            hypertext_parser.parse_links(self.text, full, self._on_link_click)\n        prefix = simpledialog.askstring(\"Prefix\",\"Optional prefix:\",initialvalue=\"Please expand:\")\n        self.processor.query_ai(selected_text, cid, on_success, lambda *_:None,\n                                 prefix=prefix, sel_start=None, sel_end=None)\n\n    def _go_back(self):\n        if not self.history:\n            messagebox.showinfo(\"BACK\",\"No history.\")\n            return\n        prev = self.history.pop()\n        self.current_doc_id = prev\n        doc = self.doc_store.get_document(prev)\n        if doc:\n            self._render_document(doc)\n        else:\n            messagebox.showerror(\"BACK\",f\"Document {prev} not found.\")\n\n    # ---- TreeView wiring ----\n    def on_tree_button(self):\n        \"\"\"Open the TreeView window using the current document as the root (if any).\"\"\"\n\n        class _DocStoreRepo:\n            \"\"\"Adapter that derives parent\u2192children from green links like (doc:123).\"\"\"\n            def __init__(self, ds):\n                self.ds = ds\n                self._roots_cache = None\n\n            def _mk_node(self, d):\n                if not d:\n                    return None\n                if isinstance(d, dict):\n                    return type(\"DocNodeShim\", (), {\n                        \"id\": d.get(\"id\"),\n                        \"title\": d.get(\"title\") or \"(untitled)\",\n                        \"parent_id\": d.get(\"parent_id\"),\n                    })()\n                # tuple/list fallback: (id, title, body, ...)\n                did = d[0] if len(d) > 0 else None\n                title = d[1] if len(d) > 1 else \"\"\n                return type(\"DocNodeShim\", (), {\"id\": did, \"title\": title or \"(untitled)\", \"parent_id\": None})()\n\n            def get_doc(self, doc_id: int):\n                return self._mk_node(self.ds.get_document(doc_id))\n\n            def _body(self, doc):\n                return doc[\"body\"] if isinstance(doc, dict) else (doc[2] if len(doc) > 2 else \"\")\n\n            def _children_from_links(self, parent_id):\n                d = self.ds.get_document(parent_id)\n                if not d:\n                    return []\n                body = self._body(d)\n                if isinstance(body, (bytes, bytearray)):\n                    return []\n                ids = [int(m) for m in re.findall(r\"\\(doc:(\\d+)\\)\", body)]\n                out = []\n                for cid in ids:\n                    nd = self.ds.get_document(cid)\n                    if nd:\n                        out.append(self._mk_node(nd))\n                out.sort(key=lambda n: n.id)\n                return out\n\n            def get_children(self, parent_id):\n                # No parent_id column in the DB, so derive from green-link references\n                if parent_id is None:\n                    if self._roots_cache is None:\n                        all_ids = [row[\"id\"] for row in self.ds.get_document_index()]\n                        referenced = set()\n                        for row in self.ds.get_document_index():\n                            d = self.ds.get_document(row[\"id\"])\n                            body = self._body(d)\n                            if isinstance(body, (bytes, bytearray)):\n                                continue\n                            referenced.update(int(m) for m in re.findall(r\"\\(doc:(\\d+)\\)\", body))\n                        # roots = docs never referenced by any other doc\n                        roots = [self._mk_node(self.ds.get_document(i)) for i in all_ids if i not in referenced]\n                        if not roots:  # fallback: show all if everything is referenced\n                            roots = [self._mk_node(self.ds.get_document(i)) for i in all_ids]\n                        self._roots_cache = [n for n in roots if n]\n                        self._roots_cache.sort(key=lambda n: n.id)\n                    return list(self._roots_cache)\n                else:\n                    return self._children_from_links(parent_id)\n\n        repo = _DocStoreRepo(self.doc_store)\n        root_id = self.current_doc_id\n        # Keep a handle so we can reuse and apply OPML expand depth\n        self.tree_win = open_tree_view(self, repo=repo, on_open_doc=self._on_link_click, root_doc_id=root_id)\n\n    def _open_opml_from_main(self):\n        path = filedialog.askopenfilename(\n            title=\"Open OPML/XML\",\n            filetypes=[(\"OPML / XML\", \"*.opml *.xml\"), (\"All files\", \"*.*\")]\n        )\n        if not path:\n            return\n        # Reuse or create the Tree window\n        if getattr(self, \"tree_win\", None) and self.tree_win.winfo_exists():\n            self.tree_win.load_opml_file(path)\n            self.tree_win.deiconify(); self.tree_win.lift()\n        else:\n            repo = type(\"EmptyRepo\", (), {\n                \"get_doc\": lambda *_: None,\n                \"get_children\": lambda *_: []\n            })()\n            self.tree_win = open_tree_view(self, repo=repo, on_open_doc=self._on_link_click, root_doc_id=None)\n            self.tree_win.load_opml_file(path)\n        self._apply_opml_expand_depth()\n\n    def _apply_opml_expand_depth(self):\n        \"\"\"Expand OPML tree to the preferred depth without touching DB lazy-loading.\"\"\"\n        win = getattr(self, \"tree_win\", None)\n        if not win or not win.winfo_exists():\n            return\n        # Use TreeView's private helper if present; else do it here by walking the widget.\n        if hasattr(win, \"_expand_to_depth\"):\n            win._expand_to_depth(self.opml_expand_depth)\n            return\n\n        # Manual expansion using the Treeview widget\n        tree = getattr(win, \"tree\", None)\n        if not tree:\n            return\n\n        def walk(iid: str, depth: int):\n            if depth >= self.opml_expand_depth:\n                return\n            win.tree.item(iid, open=True)\n            for c in win.tree.get_children(iid):\n                walk(c, depth + 1)\n\n        for top in tree.get_children(\"\"):\n            walk(top, 0)\n        # Refresh numbering if available\n        if hasattr(win, \"_update_numbering\"):\n            win._update_numbering()\n\n    def _handle_image(self):\n        try:\n            start = self.text.index(tk.SEL_FIRST)\n            end   = self.text.index(tk.SEL_LAST)\n            prompt = self.text.get(start,end).strip()\n        except tk.TclError:\n            messagebox.showwarning(\"IMAGE\",\"Please select some text first.\")\n            return\n        def wrk():\n            try:\n                pil = image_generator.generate_image(prompt)\n                self._last_pil_img = pil\n                thumb = pil.copy()\n                thumb.thumbnail((800,400))\n                self._last_tk_img = ImageTk.PhotoImage(thumb)\n                self._image_enlarged = False\n                self.after(0,lambda: self.img_label.configure(image=self._last_tk_img))\n            except Exception as e:\n                self.after(0,lambda: messagebox.showerror(\"Image Error\",str(e)))\n        threading.Thread(target=wrk,daemon=True).start()\n\n    def _toggle_image(self):\n        if not self._last_pil_img:\n            return\n        if not self._image_enlarged:\n            win = tk.Toplevel(self)\n            win.title(\"Image Preview\")\n            sw,sh=self.winfo_screenwidth(),self.winfo_screenheight()\n            iw,ih=self._last_pil_img.size\n            win.geometry(f\"{min(iw,sw)}x{min(ih,sh)}\")\n            canvas=tk.Canvas(win)\n            hbar=ttk.Scrollbar(win,orient='horizontal',command=canvas.xview)\n            vbar=ttk.Scrollbar(win,orient='vertical',command=canvas.yview)\n            canvas.configure(xscrollcommand=hbar.set,yscrollcommand=vbar.set,\n                             scrollregion=(0,0,iw,ih))\n            canvas.grid(row=0,column=0,sticky='nsew')\n            hbar.grid(row=1,column=0,sticky='we')\n            vbar.grid(row=0,column=1,sticky='ns')\n            win.grid_rowconfigure(0,weight=1)\n            win.grid_columnconfigure(0,weight=1)\n            tk_img=ImageTk.PhotoImage(self._last_pil_img)\n            canvas.create_image(0,0,anchor='nw',image=tk_img)\n            canvas.image=tk_img\n            win.bind(\"<Button-1>\",lambda e: self._toggle_image())\n            self._image_enlarged = True\n        else:\n            default=f\"document_{self.current_doc_id}.png\"\n            path=filedialog.asksaveasfilename(\n                title=\"Save Image\",initialfile=default,\n                defaultextension=\".png\",filetypes=[(\"PNG\",\"*.png\"),(\"All Files\",\"*.*\")]\n            )\n            if path:\n                try:\n                    self._last_pil_img.save(path)\n                    messagebox.showinfo(\"Save Image\",f\"Image saved to:\\n{path}\")\n                except Exception as e:\n                    messagebox.showerror(\"Save Image\",f\"Error saving image:{e}\")\n            self._image_enlarged=False\n\n    def _import_doc(self):\n        path=filedialog.askopenfilename(title=\"Import\",filetypes=[(\"Text\",\"*.txt\"),(\"All\",\"*.*\")])\n        if not path:\n            return\n        body=Path(path).read_text(encoding=\"utf-8\")\n        title=Path(path).stem\n        nid=self.doc_store.add_document(title,body)\n        self.logger.info(f\"Imported {nid}\")\n        self._refresh_sidebar()\n        doc=self.doc_store.get_document(nid)\n        if doc:\n            self._render_document(doc)\n\n    def _export_doc(self):\n        if self.current_doc_id is None:\n            messagebox.showwarning(\"Export\",\"No document loaded.\")\n            return\n        doc=self.doc_store.get_document(self.current_doc_id)\n        if not doc:\n            messagebox.showerror(\"Export\",\"Not found.\")\n            return\n        default=f\"document_{self.current_doc_id}.txt\"\n        path=filedialog.asksaveasfilename(\n            title=\"Export\",initialfile=default,defaultextension=\".txt\",\n            filetypes=[(\"Text\",\"*.txt\"),(\"All\",\"*.*\")]\n        )\n        if not path:\n            return\n        Path(path).write_text(doc[\"body\"],encoding=\"utf-8\")\n        messagebox.showinfo(\"Export\",f\"Saved to:\\n{path}\")\n\n    def _import_directory(self):\n        dir_path = filedialog.askdirectory(title=\"Select Folder to Import\")\n        if not dir_path:\n            return\n        imported, skipped = import_text_files_from_directory(dir_path, self.doc_store)\n        msg = f\"Imported {imported} file(s), skipped {skipped}.\"\n        print(\"[INFO]\", msg)\n        messagebox.showinfo(\"Directory Import\", msg)\n        self._refresh_sidebar()\n    \n    def export_and_launch_server(self):\n        export_path = Path(\"exported_docs\")\n        export_path.mkdir(exist_ok=True)\n        for doc in self.doc_store.get_document_index():\n            data = dict(self.doc_store.get_document(doc[\"id\"]))\n            if data:\n                data = sanitize_doc(data)\n                with open(export_path / f\"{data['id']}.json\", \"w\", encoding=\"utf-8\") as f:\n                    json.dump(data, f, indent=2)\n        def launch():\n            fp = Path(\"modules\") / \"flask_server.py\"\n            if fp.exists():\n                subprocess.Popen([sys.executable, str(fp)])\n        threading.Thread(target=launch, daemon=True).start()\n        messagebox.showinfo(\"Server Started\", \"Flask server launched at http://127.0.0.1:5050\")\n\n    def _save_binary_as_text(self):\n        selected_item = self.sidebar.selection() \n        if not selected_item:\n            return  # nothing selected\n        doc_id_str = self.sidebar.item(selected_item, 'values')[0]\n        if not doc_id_str.isdigit():\n            print(f\"Warning: selected text is not a valid integer '{doc_id_str}'\")\n            return\n        doc_id = int(doc_id_str)\n        doc = self.doc_store.get_document(doc_id)\n        if not doc or len(doc) < 3:\n            return\n        body = doc[2]\n        # convert only if binary\n        if isinstance(body, bytes) or ('\\x00' in str(body)):\n            print(\"Binary detected, converting to text using render_binary_as_text.\")\n            body = render_binary_as_text(body)\n            self.doc_store.update_document(doc_id, body)\n            self._render_document(self.doc_store.get_document(doc_id))\n        else:\n            print(\"Document is already text. Skipping overwrite.\")\n        content = self.processor.get_strings_content(doc_id)\n        self.doc_store.update_document(doc_id, content)\n        doc = self.doc_store.get_document(doc_id)\n        self._render_document(doc)\n\n    def _refresh_sidebar(self):\n        self.sidebar.delete(*self.sidebar.get_children())\n        for doc in self.doc_store.get_document_index():\n            self.sidebar.insert(\"\",\"end\", values=(doc[\"id\"],doc[\"title\"],doc[\"description\"]))\n\n    def _render_document(self, doc):\n        \"\"\"Render a document once (no duplicate inserts), parse green links.\"\"\"\n        # Normalize doc body\n        body = doc.get(\"body\") if isinstance(doc, dict) else (doc[2] if len(doc) > 2 else \"\")\n        self.text.delete(\"1.0\", tk.END)\n        # Guard 1: bytes\n        if isinstance(body, (bytes, bytearray)):\n            self.text.insert(tk.END, \"[binary document]\")\n            return\n        # Guard 2: oversized\n        if isinstance(body, str) and len(body) > 200_000:\n            self.text.insert(tk.END, \"[large binary-like document]\")\n            return\n        # Show and parse\n        self.text.insert(tk.END, body or \"\")\n        hypertext_parser.parse_links(self.text, body or \"\", self._on_link_click)\n\n    def _on_link_click(self, doc_id):\n        if self.current_doc_id is not None:\n            self.history.append(self.current_doc_id)\n        self.current_doc_id = doc_id\n        doc = self.doc_store.get_document(doc_id)\n        if doc:\n            self._render_document(doc)\n\n\ndef sanitize_doc(doc):\n    if isinstance(doc[\"body\"], bytes):\n        try:\n            doc[\"body\"] = doc[\"body\"].decode(\"utf-8\")\n        except UnicodeDecodeError:\n            doc[\"body\"] = doc[\"body\"].decode(\"utf-8\", errors=\"replace\")\n    return doc\n"
}