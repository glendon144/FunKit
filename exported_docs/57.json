{
  "id": 57,
  "title": "command_processor_w_memory",
  "body": "# FunKit Command Processor (updated with memory preamble + truncation)\nfrom __future__ import annotations\n\nimport os\nimport time\nfrom pathlib import Path\nfrom typing import Any, Tuple\n\nfrom modules.logger import Logger\nfrom modules.document_store import DocumentStore\nfrom modules.directory_import import import_text_files_from_directory\nfrom modules.ai_memory import get_memory, set_memory\nfrom modules.text_sanitizer import sanitize_ai_reply\n\n# Try to import a renderer for binary-as-text; provide a fallback shim if unavailable.\ntry:\n    from modules.renderer import render_binary_as_text  # type: ignore\nexcept Exception:  # pragma: no cover\n    try:\n        from modules.hypertext_parser import render_binary_as_text  # type: ignore\n    except Exception:  # pragma: no cover\n        def render_binary_as_text(data_or_path: Any, title: str = \"Document\") -> str:\n            try:\n                if isinstance(data_or_path, (bytes, bytearray)):\n                    return data_or_path.decode(\"utf-8\", errors=\"replace\")\n                if isinstance(data_or_path, str) and os.path.exists(data_or_path):\n                    with open(data_or_path, \"rb\") as f:\n                        raw = f.read()\n                    return raw.decode(\"utf-8\", errors=\"replace\")\n            except Exception:\n                pass\n            return str(data_or_path)\n\n\ndef _normalize_row(row: Any) -> Tuple[Any, str, Any]:\n    \"\"\"Normalize a document row to (id, title, body).\n    Supports sqlite3.Row (mapping-like), dict, and sequence (tuple/list).\n    \"\"\"\n    # sqlite3.Row behaves like a mapping and supports .keys() and index by column name\n    try:\n        if hasattr(row, \"keys\"):\n            keys = set(row.keys())\n            did = row[\"id\"] if \"id\" in keys else None\n            title = row[\"title\"] if \"title\" in keys else \"Document\"\n            body = row[\"body\"] if \"body\" in keys else \"\"\n            return did, (title or \"Document\"), body\n    except Exception:\n        pass\n\n    # Dict path\n    if isinstance(row, dict):\n        return row.get(\"id\"), (row.get(\"title\") or \"Document\"), row.get(\"body\")\n\n    # Sequence path (tuple/list/sqlite3.Row via index access)\n    try:\n        if not isinstance(row, (str, bytes, bytearray)) and hasattr(row, \"__getitem__\"):\n            did = row[0] if len(row) > 0 else None\n            title = row[1] if len(row) > 1 else \"Document\"\n            body = row[2] if len(row) > 2 else \"\"\n            return did, (title or \"Document\"), body\n    except Exception:\n        pass\n\n    # Fallback: treat entire row as body\n    return None, \"Document\", row\n\n\nclass CommandProcessor:\n    def __init__(self, store: DocumentStore, ai_interface, logger: Logger | None = None):\n        self.doc_store = store\n        self.ai = ai_interface\n        self.logger = logger if logger else Logger()\n\n    # --------------- Memory helpers ---------------\n\n    def _get_conn(self):\n        \"\"\"Return the SQLite connection from the document store, if available.\"\"\"\n        return getattr(self.doc_store, \"conn\", None)\n\n    def _build_memory_preamble(self, mem: dict, current_doc_id: int | None = None) -> str:\n        \"\"\"Construct a small instruction block from memory to steer the model.\"\"\"\n        if not isinstance(mem, dict):\n            return \"\"\n        persona = mem.get(\"persona\")\n        style = mem.get(\"style\")\n        rules = mem.get(\"rules\", [])\n        parts: list[str] = []\n        if persona:\n            parts.append(f\"Persona: {persona}\")\n        if style:\n            parts.append(f\"Style: {style}\")\n        if rules:\n            parts.append(\"Rules: \" + \"; \".join(rules))\n        return \"\\n\".join(parts).strip()\n\n    def _update_memory_breadcrumbs(self, prompt: str) -> None:\n        \"\"\"Record last-used time and a short rolling log of prompts.\"\"\"\n        conn = self._get_conn()\n        if not conn:\n            return\n        try:\n            mem = get_memory(conn, key=\"global\")\n            if not isinstance(mem, dict):\n                mem = {}\n            mem.setdefault(\"recent_prompts\", [])\n            mem[\"recent_prompts\"] = (mem[\"recent_prompts\"] + [prompt])[-20:]\n            mem[\"last_used\"] = int(time.time())\n            set_memory(conn, mem, key=\"global\")\n        except Exception as e:\n            # Non-fatal; keep the AI flow working even if memory write fails\n            self.logger.info(f\"Non-fatal: failed to update ai_memory: {e}\")\n\n    # --------------- Public API ---------------\n\n    def set_api_key(self, api_key: str) -> None:\n        try:\n            self.ai.set_api_key(api_key)\n            self.logger.info(\"API key successfully set in AI interface\")\n        except Exception as e:\n            self.logger.error(f\"Failed to set API key: {e}\")\n\n    def get_context_menu_actions(self) -> dict:\n        return {\n            \"Import CSV\": self.doc_store.import_csv,\n            \"Export CSV\": self.doc_store.export_csv,\n        }\n\n    def ask_question(self, prompt: str) -> str | None:\n        \"\"\"Send a standalone prompt to AI, applying memory preamble and truncation.\"\"\"\n        try:\n            conn = self._get_conn()\n            mem = get_memory(conn, key=\"global\") if conn else {}\n            preamble = self._build_memory_preamble(mem)\n            full_prompt = (preamble + \"\\n\\n\" + prompt) if preamble else prompt\n\n            self.logger.info(f\"Sending standalone prompt to AI: {full_prompt}\")\n            response = self.ai.query(full_prompt)\n            response = sanitize_ai_reply(response)\n            self.logger.info(\"AI response received successfully\")\n            self._update_memory_breadcrumbs(prompt)\n            return response\n        except Exception as e:\n            self.logger.error(f\"AI query failed: {e}\")\n            return None\n\n    def query_ai(\n        self,\n        selected_text: str,\n        current_doc_id: int,\n        on_success,\n        on_link_created,\n        prefix: str | None = None,\n        sel_start: int | None = None,\n        sel_end: int | None = None,\n    ) -> None:\n        \"\"\"\n        Send the selection to AI, create a new doc with the response, and optionally embed\n        a green link back into the source doc (text bodies only). Also applies memory preamble\n        and truncates likely-incomplete sentences.\n        \"\"\"\n        # Compose the base prompt\n        base_prompt = f\"{prefix} {selected_text}\" if prefix else f\"Please expand on this: {selected_text}\"\n\n        # Memory preamble\n        conn = self._get_conn()\n        mem = get_memory(conn, key=\"global\") if conn else {}\n        preamble = self._build_memory_preamble(mem, current_doc_id=current_doc_id)\n        prompt = (preamble + \"\\n\\n\" + base_prompt) if preamble else base_prompt\n\n        self.logger.info(f\"Sending prompt: {prompt}\")\n\n        # Call AI\n        try:\n            reply = self.ai.query(prompt)\n            reply = sanitize_ai_reply(reply)\n        except Exception as e:\n            self.logger.error(f\"AI query failed: {e}\")\n            return\n\n        self.logger.info(\"AI query successful\")\n\n        # Create the AI response document\n        new_doc_id = self.doc_store.add_document(\"AI Response\", reply)\n        self.logger.info(f\"Created new document {new_doc_id}\")\n\n        # Try to embed a green link in the original text document\n        try:\n            original = self.doc_store.get_document(current_doc_id)\n        except Exception as e:\n            original = None\n            self.logger.error(f\"Failed to load original doc {current_doc_id}: {e}\")\n\n        if original is not None:\n            try:\n                _, _title, body = _normalize_row(original)\n            except Exception:\n                body = \"\"\n\n            if isinstance(body, str) and selected_text:\n                link_md = f\"[{selected_text}](doc:{new_doc_id})\"\n                updated: str | None = None\n\n                # If explicit offsets are provided and valid, use them\n                if (\n                    isinstance(sel_start, int)\n                    and isinstance(sel_end, int)\n                    and 0 <= sel_start < sel_end <= len(body)\n                ):\n                    updated = body[:sel_start] + link_md + body[sel_end:]\n                    self.logger.info(f\"Embedded link at offsets {sel_start}-{sel_end}\")\n                else:\n                    # Fallback: first occurrence replacement\n                    if selected_text in body:\n                        updated = body.replace(selected_text, link_md, 1)\n                        self.logger.info(\"Embedded link by substring replace\")\n                    else:\n                        self.logger.info(\"Selected text not found; original unchanged\")\n\n                if updated is not None and updated != body:\n                    try:\n                        if hasattr(self.doc_store, \"update_document_body\"):\n                            self.doc_store.update_document_body(current_doc_id, updated)\n                        else:\n                            # Some stores expose a generic update_document(id, body)\n                            self.doc_store.update_document(current_doc_id, updated)  # type: ignore\n                    except Exception as e:\n                        self.logger.error(f\"Failed updating original doc {current_doc_id}: {e}\")\n            else:\n                # Skip binary or missing bodies\n                if isinstance(body, (bytes, bytearray)):\n                    self.logger.info(\"Original doc is binary; skipping in-place link embed.\")\n        else:\n            self.logger.error(f\"Original document {current_doc_id} not found\")\n\n        # Update memory breadcrumbs (non-fatal on error)\n        try:\n            self._update_memory_breadcrumbs(base_prompt)\n        except Exception:\n            pass\n\n        # Fire UI callbacks\n        try:\n            on_link_created(selected_text)\n        except Exception as e:\n            self.logger.info(f\"on_link_created callback failed (non-fatal): {e}\")\n        try:\n            on_success(new_doc_id)\n        except Exception as e:\n            self.logger.info(f\"on_success callback failed (non-fatal): {e}\")\n\n    # --------------- External file operations ---------------\n\n    def import_document_from_path(self, path: str) -> int:\n        \"\"\"Import a file from *path* and return new document ID.\"\"\"\n        p = Path(path)\n        title = p.stem\n        try:\n            text = p.read_text(encoding=\"utf-8\")\n            return self.doc_store.add_document(title, text)\n        except UnicodeDecodeError:\n            data = p.read_bytes()  # store as SQLite BLOB\n            return self.doc_store.add_document(title, data)\n\n    def export_document_to_path(self, doc_id: int, path: str) -> None:\n        \"\"\"Export document *doc_id* to filesystem path.\"\"\"\n        row = self.doc_store.get_document(doc_id)\n\n        if hasattr(row, \"keys\"):  # sqlite3.Row with mapping behavior\n            body = row[\"body\"] if row else \"\"\n        elif isinstance(row, dict):\n            body = row.get(\"body\")\n        else:\n            body = row[2] if row and len(row) > 2 else \"\"\n\n        p = Path(path)\n        if isinstance(body, (bytes, bytearray)):\n            p.write_bytes(bytes(body))\n        else:\n            p.write_text(\"\" if body is None else str(body), encoding=\"utf-8\")\n\n    # --------------- Render helpers ---------------\n\n    def get_strings_content(self, doc_id: int) -> str:\n        \"\"\"Return a text rendering of the document suitable for display/export.\"\"\"\n        try:\n            row = self.doc_store.get_document(doc_id)\n        except Exception:\n            row = None\n\n        if not row:\n            return \"[ERROR] Document not found.\"\n\n        _id, title, body = _normalize_row(row)\n\n        # If body looks like a filesystem path and exists, prefer that\n        if isinstance(body, str) and os.path.exists(body):\n            try:\n                return render_binary_as_text(body, title)\n            except Exception:\n                pass\n\n        # If it's bytes/bytearray, convert via renderer\n        if isinstance(body, (bytes, bytearray)):\n            return render_binary_as_text(body, title)\n\n        # Else, return text as-is\n        return str(body or \"\")\n\n    # --------------- Bulk imports ---------------\n\n    def import_opml_from_path(self, path: str) -> int:\n        \"\"\"Import an OPML/XML file from *path* and return new document ID.\"\"\"\n        content = Path(path).read_text(encoding=\"utf-8\", errors=\"replace\")\n        title = Path(path).stem\n        return self.doc_store.add_document(title, content)\n\n    def import_directory(self, directory: str) -> None:\n        \"\"\"Bulk-import text files from a directory.\"\"\"\n        import_text_files_from_directory(self.doc_store, directory)\n"
}