{
  "id": 90,
  "title": "generate_url_opml_helper",
  "body": "# Regenerate opml_extras_plugin_v3.py with robust multi-URL parsing and batch convert.\nfrom pathlib import Path\n\ncode = r'''\"\"\"\nopml_extras_plugin_v3.py \u2014 OPML utilities (URL import, selection\u2192OPML, batch convert)\n\nInstall (after creating the app in main.py):\n    from modules.opml_extras_plugin_v3 import install_opml_extras_into_app\n    install_opml_extras_into_app(app)\n\nFeatures\n- URL \u2192 OPML: accepts spaces, commas, semicolons, and newlines between URLs; auto-adds https:// if missing.\n- Convert Selection \u2192 OPML: converts the current selection (or whole text doc if no selection) to OPML.\n- Batch: Convert Selected \u2192 OPML: converts multiple sidebar-selected docs to OPML as new docs.\n- Uses modules.aopmlengine if available; otherwise falls back to lightweight converters.\n- Safe for sqlite3.Row/dict/tuple documents; UI updates happen on Tk main thread.\n\"\"\"\n\nfrom __future__ import annotations\nimport re\nimport threading\nimport urllib.request\nimport urllib.error\n\n# Optional advanced engine\nAOPML = None\ntry:\n    from modules import aopmlengine as AOPML  # type: ignore\nexcept Exception:\n    AOPML = None  # type: ignore\n\n\n# ----------------- Helpers -----------------\n\ndef _norm_row(row):\n    \"\"\"Normalize a document to (id, title, body). Supports sqlite3.Row/dict/tuple/list.\"\"\"\n    if row is None:\n        return None, \"Document\", \"\"\n    try:\n        if hasattr(row, \"keys\"):\n            rid = row[\"id\"] if \"id\" in row.keys() else None\n            title = row[\"title\"] if \"title\" in row.keys() else \"Document\"\n            body = row[\"body\"] if \"body\" in row.keys() else \"\"\n            return rid, title or \"Document\", body\n    except Exception:\n        pass\n    if isinstance(row, dict):\n        return row.get(\"id\"), (row.get(\"title\") or \"Document\"), row.get(\"body\")\n    try:\n        if not isinstance(row, (str, bytes, bytearray)) and hasattr(row, \"__getitem__\"):\n            rid = row[0] if len(row) > 0 else None\n            title = row[1] if len(row) > 1 else \"Document\"\n            body = row[2] if len(row) > 2 else \"\"\n            return rid, title or \"Document\", body\n    except Exception:\n        pass\n    return None, \"Document\", row\n\n\ndef _simple_text_to_opml(text: str, title: str = \"Imported Text\") -> str:\n    \"\"\"Lightweight text\u2192OPML when AOPML is unavailable.\"\"\"\n    text = (text or \"\").strip()\n    lines = [ln.strip() for ln in text.splitlines()]\n    outlines = []\n    for ln in lines:\n        if not ln:\n            continue\n        txt = ln.replace(\"&\", \"&amp;\").replace('\"', \"&quot;\").replace(\"<\", \"&lt;\")\n        outlines.append(f'<outline text=\"{txt}\"/>\\n')\n    body = \"\".join(outlines) or '<outline text=\"[empty]\"/>\\n'\n    return (\n        '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n'\n        '<opml version=\"2.0\">\\n'\n        f'<head><title>{title}</title></head>\\n'\n        '<body>\\n' + body + '</body>\\n</opml>\\n'\n    )\n\n\ndef _simple_html_to_opml(html: str, title: str = \"Imported HTML\") -> str:\n    \"\"\"Minimal HTML\u2192OPML using headings; used if AOPML is missing.\"\"\"\n    s = html or \"\"\n    # collect headings in order of appearance\n    pats = [\n        (1, re.compile(r\"<h1[^>]*>(.*?)</h1>\", re.I | re.S)),\n        (2, re.compile(r\"<h2[^>]*>(.*?)</h2>\", re.I | re.S)),\n        (3, re.compile(r\"<h3[^>]*>(.*?)</h3>\", re.I | re.S)),\n        (4, re.compile(r\"<h4[^>]*>(.*?)</h4>\", re.I | re.S)),\n    ]\n    items = []\n    # Using finditer across the whole text for each heading level is simple and robust enough\n    for level, pat in pats:\n        for m in pat.finditer(s):\n            txt = re.sub(r\"<[^>]+>\", \"\", m.group(1))\n            txt = re.sub(r\"\\s+\", \" \", txt).strip()\n            if txt:\n                items.append((level, txt))\n    if not items:\n        # Fallback to paragraphs\n        paras = re.split(r\"</p>|<br\\s*/?>\", s, flags=re.I)\n        items = [(3, re.sub(r\"<[^>]+>\", \"\", p).strip()) for p in paras if re.sub(r\"<[^>]+>\", \"\", p).strip()]\n    # Build nested OPML by level\n    out = [\n        '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<opml version=\"2.0\">\\n',\n        f'<head><title>{title}</title></head>\\n<body>\\n',\n    ]\n    stack = [0]\n    for lvl, text in items:\n        text_esc = text.replace(\"&\", \"&amp;\").replace('\"', \"&quot;\").replace(\"<\", \"&lt;\")\n        while stack and lvl <= stack[-1]:\n            out.append(\"</outline>\\n\")\n            stack.pop()\n        out.append(f'<outline text=\"{text_esc}\">')\n        stack.append(lvl)\n    while len(stack) > 1:\n        out.append(\"</outline>\\n\")\n        stack.pop()\n    if len(out) < 3:\n        out.append('<outline text=\"[empty]\"/>\\n')\n    out.append(\"</body>\\n</opml>\\n\")\n    return \"\".join(out)\n\n\ndef _to_opml(text_or_html: str, title: str = \"Imported\"):\n    \"\"\"Use AOPML if available; else heuristic to text/html converters.\"\"\"\n    if AOPML is not None:\n        # Try module function\n        fn = getattr(AOPML, \"convert_text_or_html_to_opml\", None)\n        if callable(fn):\n            try:\n                return fn(text_or_html, title=title)\n            except Exception:\n                pass\n        # Try class-based engine\n        cls = getattr(AOPML, \"AopmlEngine\", None)\n        if cls is not None:\n            try:\n                eng = cls()\n                return eng.convert_text_or_html_to_opml(text_or_html, title=title)\n            except Exception:\n                pass\n    low = (text_or_html or \"\").lower()\n    if \"<html\" in low or \"<body\" in low or \"<div\" in low or \"<p\" in low:\n        return _simple_html_to_opml(text_or_html, title)\n    else:\n        return _simple_text_to_opml(text_or_html, title)\n\n\ndef _fetch_url_text(url: str, timeout: float = 12.0) -> str:\n    \"\"\"Fetch URL and return decoded text with best-effort charset detection.\"\"\"\n    req = urllib.request.Request(\n        url,\n        headers={\n            \"User-Agent\": \"FunKit/1.0 (+URL\u2192OPML)\",\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.9\",\n        },\n        method=\"GET\",\n    )\n    with urllib.request.urlopen(req, timeout=timeout) as resp:\n        raw = resp.read()\n        ctype = resp.headers.get(\"Content-Type\", \"\") or \"\"\n        enc = \"utf-8\"\n        m = re.search(r\"charset=([\\w\\-\\d]+)\", ctype, re.I)\n        if m:\n            enc = m.group(1)\n        try:\n            return raw.decode(enc, errors=\"replace\")\n        except Exception:\n            return raw.decode(\"utf-8\", errors=\"replace\")\n\n\ndef _parse_multi_input(s: str) -> list[str]:\n    \"\"\"Split user input into URLs on spaces/commas/semicolons/newlines and normalize.\"\"\"\n    tokens = re.split(r\"[,\\s;]+\", (s or \"\").strip())\n    out: list[str] = []\n    for t in tokens:\n        if not t:\n            continue\n        u = t.strip(' <>\\\"\\'()[]')\n        if not u:\n            continue\n        # Add scheme if missing\n        if not re.match(r\"^[a-zA-Z][a-zA-Z0-9+.\\-]*://\", u):\n            u = \"https://\" + u\n        out.append(u)\n    # de-dup while preserving order\n    seen = set()\n    uniq = []\n    for u in out:\n        if u not in seen:\n            seen.add(u)\n            uniq.append(u)\n    return uniq\n\n\n# ----------------- Actions -----------------\n\ndef _action_import_url_as_opml(app):\n    SD = __import__(\"tkinter.simpledialog\", fromlist=[\"simpledialog\"]).simpledialog\n    MB = __import__(\"tkinter.messagebox\", fromlist=[\"messagebox\"]).messagebox\n\n    urls_text = SD.askstring(\n        \"URL \u2192 OPML\",\n        \"Enter URL(s) separated by spaces, commas, semicolons, or newlines:\",\n    )\n    if not urls_text:\n        return\n    urls = _parse_multi_input(urls_text)\n    if not urls:\n        MB.showwarning(\"URL \u2192 OPML\", \"No valid URLs provided.\")\n        return\n\n    results = {\"ok\": [], \"fail\": []}\n\n    def worker():\n        for u in urls:\n            try:\n                html = _fetch_url_text(u)\n                title_guess = re.sub(r\"^https?://(www\\\\.)?\", \"\", u).rstrip(\"/\")\n                opml = _to_opml(html, title=title_guess)\n                nid = app.doc_store.add_document(f\"{title_guess}\", opml)\n                results[\"ok\"].append((u, nid))\n            except Exception as e:\n                results[\"fail\"].append((u, str(e)))\n\n        def done():\n            app._refresh_sidebar()\n            if results[\"ok\"]:\n                last_id = results[\"ok\"][-1][1]\n                app.current_doc_id = last_id\n                doc = app.doc_store.get_document(last_id)\n                if doc:\n                    app._render_document(doc)\n            # summarize\n            msg = [f\"Imported {len(results['ok'])}; Failed {len(results['fail'])}.\"]\n            if results[\"fail\"]:\n                for u, err in results[\"fail\"][:5]:\n                    msg.append(f\" - {u} \u2192 {err}\")\n                if len(results[\"fail\"]) > 5:\n                    msg.append(f\" ... and {len(results['fail']) - 5} more.\")\n            MB.showinfo(\"URL \u2192 OPML\", \"\\n\".join(msg))\n\n        app.after(0, done)\n\n    threading.Thread(target=worker, daemon=True).start()\n\n\ndef _action_convert_selection_to_opml(app):\n    MB = __import__(\"tkinter.messagebox\", fromlist=[\"messagebox\"]).messagebox\n    tk = __import__(\"tkinter\")\n\n    # Try selection from the text widget\n    text = None\n    try:\n        start = app.text.index(tk.SEL_FIRST)\n        end = app.text.index(tk.SEL_LAST)\n        text = app.text.get(start, end)\n    except Exception:\n        text = None\n\n    title = \"OPML from Selection\"\n    if not text and getattr(app, \"current_doc_id\", None) is not None:\n        row = app.doc_store.get_document(app.current_doc_id)\n        _, title0, body = _norm_row(row)\n        title = f\"OPML for {title0}\"\n        if isinstance(body, (bytes, bytearray)):\n            MB.showwarning(\"Convert \u2192 OPML\", \"Current document is binary; select text in the pane to convert.\")\n            return\n        text = str(body or \"\")\n    if not text:\n        MB.showwarning(\"Convert \u2192 OPML\", \"Nothing to convert\u2014select some text or open a text document.\")\n        return\n\n    opml = _to_opml(text, title=title)\n    nid = app.doc_store.add_document(title, opml)\n    app._refresh_sidebar()\n    app.current_doc_id = nid\n    doc = app.doc_store.get_document(nid)\n    if doc:\n        app._render_document(doc)\n\n\ndef _action_batch_convert_selected_to_opml(app):\n    MB = __import__(\"tkinter.messagebox\", fromlist=[\"messagebox\"]).messagebox\n    sel = getattr(app, \"sidebar\", None)\n    if not sel:\n        MB.showwarning(\"Batch Convert\", \"Sidebar not available for selection.\")\n        return\n    items = sel.selection()\n    if not items:\n        MB.showwarning(\"Batch Convert\", \"Select one or more documents in the left list first.\")\n        return\n\n    ids = []\n    for iid in items:\n        try:\n            vals = sel.item(iid, \"values\")\n            did = int(vals[0])\n            ids.append(did)\n        except Exception:\n            continue\n\n    if not ids:\n        MB.showwarning(\"Batch Convert\", \"No valid document IDs in selection.\")\n        return\n\n    results = {\"ok\": [], \"skip\": [], \"fail\": []}\n\n    def worker():\n        for did in ids:\n            try:\n                row = app.doc_store.get_document(did)\n                _, title, body = _norm_row(row)\n                if isinstance(body, (bytes, bytearray)):\n                    results[\"skip\"].append((did, \"binary\"))\n                    continue\n                text = str(body or \"\")\n                if \"<opml\" in text.lower():\n                    results[\"skip\"].append((did, \"already OPML\"))\n                    continue\n                opml = _to_opml(text, title=f\"OPML for {title}\")\n                nid = app.doc_store.add_document(f\"OPML for {title}\", opml)\n                results[\"ok\"].append((did, nid))\n            except Exception as e:\n                results[\"fail\"].append((did, str(e)))\n\n        def done():\n            app._refresh_sidebar()\n            msg = [\n                f\"Batch complete: {len(results['ok'])} converted, {len(results['skip'])} skipped, {len(results['fail'])} failed.\"\n            ]\n            if results[\"fail\"]:\n                for did, err in results[\"fail\"][:5]:\n                    msg.append(f\" - id {did} \u2192 {err}\")\n                if len(results[\"fail\"]) > 5:\n                    msg.append(f\" ... and {len(results['fail']) - 5} more.\")\n            MB.showinfo(\"Batch Convert \u2192 OPML\", \"\\n\".join(msg))\n\n        app.after(0, done)\n\n    threading.Thread(target=worker, daemon=True).start()\n\n\n# ----------------- Install -----------------\n\ndef install_opml_extras_into_app(app):\n    \"\"\"Wire menu items, hotkeys, and (if present) toolbar buttons into the running app.\"\"\"\n    # Menu retrieval / creation\n    menu = None\n    try:\n        menu = app.nametowidget(app.cget(\"menu\"))\n    except Exception:\n        pass\n    if menu is None:\n        import tkinter as tk\n        menu = tk.Menu(app)\n        app.config(menu=menu)\n\n    import tkinter as tk\n    opml_menu = tk.Menu(menu, tearoff=0)\n    opml_menu.add_command(label=\"URL \u2192 OPML\u2026\", command=lambda a=app: _action_import_url_as_opml(a))\n    opml_menu.add_command(label=\"Convert Selection \u2192 OPML\", command=lambda a=app: _action_convert_selection_to_opml(a))\n    opml_menu.add_command(label=\"Batch: Convert Selected \u2192 OPML\", command=lambda a=app: _action_batch_convert_selected_to_opml(a))\n    menu.add_cascade(label=\"OPML\", menu=opml_menu)\n\n    # Hotkeys\n    app.bind(\"<Control-u>\", lambda e, a=app: _action_import_url_as_opml(a))\n    app.bind(\"<Control-U>\", lambda e, a=app: _action_import_url_as_opml(a))\n    for seq in (\"<Control-Shift-o>\", \"<Control-Alt-o>\", \"<F6>\"):\n        app.bind(seq, lambda e, a=app: _action_convert_selection_to_opml(a))\n    app.bind(\"<Shift-F6>\", lambda e, a=app: _action_batch_convert_selected_to_opml(a))\n\n    # Optional toolbar buttons (if a toolbar frame exists)\n    for attr in (\"toolbar\", \"_toolbar\", \"toolbar_frame\", \"_toolbar_frame\"):\n        tb = getattr(app, attr, None)\n        if tb:\n            try:\n                import tkinter.ttk as ttk\n                ttk.Button(tb, text=\"URL \u2192 OPML\", command=lambda a=app: _action_import_url_as_opml(a)).pack(side=\"left\", padx=4)\n                ttk.Button(tb, text=\"Convert \u2192 OPML\", command=lambda a=app: _action_convert_selection_to_opml(a)).pack(side=\"left\", padx=4)\n                ttk.Button(tb, text=\"Batch \u2192 OPML\", command=lambda a=app: _action_batch_convert_selected_to_opml(a)).pack(side=\"left\", padx=4)\n                break\n            except Exception:\n                pass\n'''\n\np = Path('/mnt/data/opml_extras_plugin_v3.py')\np.write_text(code, encoding='utf-8')\nprint(p.as_posix())\n\n"
}