{
  "id": 28,
  "title": "Polygon_Generator",
  "body": "```javascript\n/***************************************************************************************************\n *  3\u2011D POLYHEDRON VISUALISER \u2013 A TEACHER'S WALKTHROUGH\n *\n *  This script builds an interactive WebGL scene using the THREE.js library.  The user can\n *  select the level of geometric detail, the type of polyhedron (tetrahedron, hexahedron, \u2026),\n *  and the material applied (normal shading, solid colour, or a texture).  The vertices of the\n *  displayed shape are continuously interpolated with a second, slightly larger shape, creating\n *  a mesmerizing \u201cbreathing\u201d animation that can be toggled by clicking near the centre of the\n *  canvas.\n *\n *  Throughout the source you will find extensive commentary.  Jargon is introduced only once\n *  \u2013 for instance, **geometry** is defined the first time it appears \u2013 and thereafter the same\n *  term is reused without re\u2011definition.  Wherever a concept is abstract (e.g. the creation of a\n *  *BufferAttribute*), a concrete example is given to cement understanding.\n *\n *  The final block of comments (the \u201cSummary\u201d) recaps the program\u2019s architecture, the data\u2011flow,\n *  and a minimal example of how to embed the visualiser in an HTML page.\n ***************************************************************************************************/\n\n// -----------------------------------------------------------------------------\n// GLOBAL STATE \u2013 variables that control the animation and user\u2011chosen options\n// -----------------------------------------------------------------------------\n// n \u2013 the number of subdivisions (detail) for the chosen geometry.  Subdivisions\n//     increase the number of faces, making the shape smoother.  Initially zero.\nlet n = 0;\n\n// mat \u2013 a string identifier for the current material mode (Normal, Color, Texture).\nlet mat = 0;\n\n// triangles \u2013 a helper that records how many triangle groups a particular shape\n//            contains; used when computing per\u2011triangle colour data.\nlet triangles = 1;\n\n// clique \u2013 a Boolean that toggles the interpolation between two shapes.\n//          When true the vertices of the small and large polyhedra are blended.\nlet clique = true;\n\n// -----------------------------------------------------------------------------\n// THREE.js CORE COMPONENTS \u2013 scene, camera, renderer\n// -----------------------------------------------------------------------------\n// scene \u2013 the container that holds every object we wish to render.  Think of it as a\n//         virtual stage.\nconst scene = new THREE.Scene();\n\n// camera \u2013 a *PerspectiveCamera* mimics the way a human eye perceives depth.\n//          The first argument (75) is the field\u2011of\u2011view in degrees; the next two\n//          arguments define the aspect ratio and the near/far clipping planes.\nconst camera = new THREE.PerspectiveCamera(\n\t75,                                   // field\u2011of\u2011view\n\twindow.innerWidth / window.innerHeight, // aspect ratio\n\t0.1,                                 // near clipping plane\n\t1000                                   // far clipping plane\n);\n\n// renderer \u2013 the engine that draws the scene onto a HTML canvas.  The antialias\n//            option smooths jagged edges, improving visual quality.\nconst renderer = new THREE.WebGLRenderer({ antialias: true });\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement); // inject the canvas into the page\n\n// -----------------------------------------------------------------------------\n// GEOMETRY CREATION \u2013 two Icosahedron meshes of different radii (1 and 1.5)\n// -----------------------------------------------------------------------------\n// IcosahedronGeometry \u2013 a class that builds a regular 20\u2011sided polyhedron.\n// The second argument, `n`, determines the number of recursive subdivisions.\nconst geometry = new THREE.IcosahedronGeometry(1, n);\nlet positions = geometry.getAttribute('position'); // *position* is a BufferAttribute\n\n// A second, slightly larger geometry that will serve as the target for interpolation.\nlet geometry2 = new THREE.IcosahedronGeometry(1.5, n);\nlet positions2 = geometry2.getAttribute('position');\n\n// Number of components per vertex attribute:\n//   position \u2192 3"
}