diff --git a/modules/gui_tkinter.py b/modules/gui_tkinter.py
index de360b1c70086840f3bb52420ec88635c5d78e78..cb875c7895b1ebc3462111db4a74b1e527ef40bf 100644
--- a/modules/gui_tkinter.py
+++ b/modules/gui_tkinter.py
@@ -1,100 +1,103 @@
 import os
 import threading
 import tkinter as tk
-from tkinter import ttk, filedialog, simpledialog, messagebox
+from tkinter import ttk, simpledialog, messagebox
 from pathlib import Path
 from PIL import ImageTk, Image
-import subprocess
-import sys
 import json
 import re
 import xml.etree.ElementTree as ET
 
 # === Tri-model integration imports ===
 from concurrent.futures import ThreadPoolExecutor
-from tkinter import messagebox
 from modules.tri_pipeline import run_tri_pipeline
 from modules.ai_memory import get_memory, set_memory
 
 
 # PiKit modules
-from modules import hypertext_parser, image_generator, document_store
-from modules.renderer import render_binary_as_text
+from modules import hypertext_parser, image_generator
 from modules.logger import Logger
-from modules.directory_import import import_text_files_from_directory
 from modules.TreeView import open_tree_view
+from modules.gui_actions import (
+    import_doc,
+    export_doc,
+    save_binary_as_text,
+    import_directory,
+    open_opml_from_main,
+    export_and_launch_server,
+)
 
 SETTINGS_FILE = Path("pikit_settings.json")
 
 
 class DemoKitGUI(tk.Tk):
 
     def _on_image_clicked(self):
         """Image generation disabled here: viewing images is local-only.
         Hook your OpenAI-powered generation here if/when you want it."""
         from tkinter import messagebox
         messagebox.showinfo("Image", "Local image rendering is enabled. Generation is disabled in this build.")
     """PiKit / DemoKit GUI with OPML auto-rendering in the document pane, TreeView integration, and utilities."""
 
     SIDEBAR_WIDTH = 320
 
     def __init__(self, doc_store, processor):
         super().__init__()
         self.doc_store = doc_store
         self.processor = processor
         self.logger: Logger = getattr(processor, "logger", Logger())
         self.current_doc_id: int | None = None
         self.history: list[int] = []
 # idempotent;  safe to call each startup
         # image state
         self._last_pil_img: Image.Image | None = None
         self._last_tk_img: ImageTk.PhotoImage | None = None
         self._image_enlarged: bool = False
 
         # ---- Settings ----
         self.settings = self._load_settings()
         self.opml_expand_depth: int = int(self.settings.get("opml_expand_depth", 2))
 
         self.title("Engelbart Journal – DemoKit")
         self.geometry("1200x800")
         self.columnconfigure(0, minsize=self.SIDEBAR_WIDTH, weight=0)
         self.columnconfigure(1, weight=1)
         self.rowconfigure(0, weight=1)
 
         self._build_sidebar()
         self._build_main_pane()
         self._build_context_menu()
 
         # --- Menubar ---
         menubar = tk.Menu(self)
         # File menu
         filemenu = tk.Menu(menubar, tearoff=0)
-        filemenu.add_command(label="Import", command=self._import_doc)
-        filemenu.add_command(label="Export Current", command=self._export_doc)
+        filemenu.add_command(label="Import", command=lambda: import_doc(self))
+        filemenu.add_command(label="Export Current", command=lambda: export_doc(self))
         filemenu.add_separator()
-        filemenu.add_command(label="Export to Intraweb", command=self.export_and_launch_server)
+        filemenu.add_command(label="Export to Intraweb", command=lambda: export_and_launch_server(self))
         filemenu.add_separator()
         filemenu.add_command(label="Quit", command=self.destroy)
         menubar.add_cascade(label="File", menu=filemenu)
 
         # View menu (adds TreeView entry + shortcut + depth)
         viewmenu = tk.Menu(menubar, tearoff=0)
         viewmenu.add_command(label="Document Tree\tCtrl+T", command=self.on_tree_button)
         viewmenu.add_separator()
         viewmenu.add_command(label="Set OPML Expand Depth…", command=self._set_opml_expand_depth)
         menubar.add_cascade(label="View", menu=viewmenu)
 
         self.config(menu=menubar)
         # AI menu
         ai_menu = tk.Menu(menubar, tearoff=0)
         ai_menu.add_command(label="ASK (Tri)", command=self.ask_tri_action, accelerator="Ctrl+Shift+A")
         menubar.add_cascade(label="AI", menu=ai_menu)
 
         # Keyboard shortcut
         self.bind("<Control-t>", lambda e: self.on_tree_button())
 
         self.bind_all("<Control-Shift-A>", lambda e: self.ask_tri_action())
 
         self._refresh_sidebar()
         # Thread pool (keeps UI responsive during API calls)
         self.executor = getattr(self, "executor", ThreadPoolExecutor(max_workers=2))
diff --git a/modules/gui_tkinter.py b/modules/gui_tkinter.py
index de360b1c70086840f3bb52420ec88635c5d78e78..cb875c7895b1ebc3462111db4a74b1e527ef40bf 100644
--- a/modules/gui_tkinter.py
+++ b/modules/gui_tkinter.py
@@ -171,74 +174,74 @@ class DemoKitGUI(tk.Tk):
     # ---------------- Main Pane ----------------
 
     def _build_main_pane(self):
         pane = tk.Frame(self)
         pane.grid(row=0, column=1, sticky="nswe", padx=4, pady=4)
         pane.rowconfigure(0, weight=3)
         pane.rowconfigure(1, weight=1)
         pane.columnconfigure(0, weight=1)
 
         self.text = tk.Text(pane, wrap="word")
         self.text.grid(row=0, column=0, sticky="nswe")
         self.text.tag_configure("link", foreground="green", underline=True)
         self.text.bind("<Button-3>", self._show_context_menu)
         self.text.bind("<Delete>", lambda e: self._on_delete_clicked())
 
         self.img_label = tk.Label(pane)
         self.img_label.grid(row=1, column=0, sticky="ew", pady=(8, 0))
         self.img_label.bind("<Button-1>", lambda e: self._toggle_image())
 
         btns = tk.Frame(pane)
         btns.grid(row=2, column=0, sticky="we", pady=(6, 0))
         self.toolbar = btns   # <- expose the toolbar so plugins can attach buttons
 
         acts = [
             ("TREE", self.on_tree_button),
-            ("OPEN OPML", self._open_opml_from_main),
+            ("OPEN OPML", lambda: open_opml_from_main(self)),
             ("ASK", self._handle_ask),
             ("ASK (Tri)", self.ask_tri_action),
             ("BACK", self._go_back),
             ("DELETE", self._on_delete_clicked),
             ("IMAGE", self._handle_image),
-            ("FLASK", self.export_and_launch_server),
-            ("DIR IMPORT", self._import_directory),
-            ("SAVE AS TEXT", self._save_binary_as_text),
+            ("FLASK", lambda: export_and_launch_server(self)),
+            ("DIR IMPORT", lambda: import_directory(self)),
+            ("SAVE AS TEXT", lambda: save_binary_as_text(self)),
         ]
         for i, (lbl, cmd) in enumerate(acts):
             ttk.Button(btns, text=lbl, command=cmd).grid(row=0, column=i, sticky="we", padx=(0, 4))
 
     # ---------------- Context Menu ----------------
 
     def _build_context_menu(self):
         self.context_menu = tk.Menu(self, tearoff=0)
         self.context_menu.add_command(label="ASK", command=self._handle_ask)
         self.context_menu.add_command(label="ASK (Tri)", command=self.ask_tri_action)
         self.context_menu.add_command(label="Delete", command=self._on_delete_clicked)
         self.context_menu.add_separator()
-        self.context_menu.add_command(label="Import", command=self._import_doc)
-        self.context_menu.add_command(label="Export", command=self._export_doc)
-        self.context_menu.add_command(label="Save Binary As Text", command=self._save_binary_as_text)
+        self.context_menu.add_command(label="Import", command=lambda: import_doc(self))
+        self.context_menu.add_command(label="Export", command=lambda: export_doc(self))
+        self.context_menu.add_command(label="Save Binary As Text", command=lambda: save_binary_as_text(self))
 
     def _show_context_menu(self, event):
         try:
             self.context_menu.tk_popup(event.x_root, event.y_root)
         finally:
             self.context_menu.grab_release()
 
     # ---------------- ASK / BACK ----------------
 
     def _handle_ask(self):
         try:
             start = self.text.index(tk.SEL_FIRST)
             end = self.text.index(tk.SEL_LAST)
             selected_text = self.text.get(start, end)
         except tk.TclError:
             messagebox.showwarning("ASK", "Please select some text first.")
             return
 
         cid = self.current_doc_id
 
         def on_success(nid):
             messagebox.showinfo("ASK", f"Created new document {nid}.")
             self._refresh_sidebar()
             # replace selection with link
             self.text.delete(start, end)
diff --git a/modules/gui_tkinter.py b/modules/gui_tkinter.py
index de360b1c70086840f3bb52420ec88635c5d78e78..cb875c7895b1ebc3462111db4a74b1e527ef40bf 100644
--- a/modules/gui_tkinter.py
+++ b/modules/gui_tkinter.py
@@ -649,277 +652,95 @@ class DemoKitGUI(tk.Tk):
 
     def _toggle_image(self):
         if not self._last_pil_img:
             return
         if not self._image_enlarged:
             win = tk.Toplevel(self)
             win.title("Image Preview")
             sw, sh = self.winfo_screenwidth(), self.winfo_screenheight()
             iw, ih = self._last_pil_img.size
             win.geometry(f"{min(iw, sw)}x{min(ih, sh)}")
             canvas = tk.Canvas(win)
             hbar = ttk.Scrollbar(win, orient="horizontal", command=canvas.xview)
             vbar = ttk.Scrollbar(win, orient="vertical", command=canvas.yview)
             canvas.configure(xscrollcommand=hbar.set, yscrollcommand=vbar.set, scrollregion=(0, 0, iw, ih))
             canvas.grid(row=0, column=0, sticky="nsew")
             hbar.grid(row=1, column=0, sticky="we")
             vbar.grid(row=0, column=1, sticky="ns")
             win.grid_rowconfigure(0, weight=1)
             win.grid_columnconfigure(0, weight=1)
             tk_img = ImageTk.PhotoImage(self._last_pil_img)
             canvas.create_image(0, 0, anchor="nw", image=tk_img)
             canvas.image = tk_img
             win.bind("<Button-1>", lambda e: self._toggle_image())
             self._image_enlarged = True
         else:
+            from tkinter import filedialog
+
             default = f"document_{self.current_doc_id}.png"
             path = filedialog.asksaveasfilename(
                 title="Save Image",
                 initialfile=default,
                 defaultextension=".png",
                 filetypes=[("PNG", "*.png"), ("All Files", "*.*")],
             )
             if path:
                 try:
                     self._last_pil_img.save(path)
                     messagebox.showinfo("Save Image", f"Image saved to:\n{path}")
                 except Exception as e:
                     messagebox.showerror("Save Image", f"Error saving image:{e}")
             self._image_enlarged = False
 
     def _handle_image(self):
         try:
             start = self.text.index(tk.SEL_FIRST)
             end = self.text.index(tk.SEL_LAST)
             prompt = self.text.get(start, end).strip()
         except tk.TclError:
             messagebox.showwarning("IMAGE", "Please select some text first.")
             return
 
         def wrk():
             try:
                 pil = image_generator.generate_image(prompt)
                 self._last_pil_img = pil
                 thumb = pil.copy()
                 thumb.thumbnail((800, 400))
                 self._last_tk_img = ImageTk.PhotoImage(thumb)
                 self._image_enlarged = False
                 self.after(0, lambda: self.img_label.configure(image=self._last_tk_img))
             except Exception as e:
                 err = str(e)  # capture inside the except scope
                 self.after(0, lambda err=err: messagebox.showerror("Image Error", err))
 
         threading.Thread(target=wrk, daemon=True).start()
 
     # ---------------- Import/Export ----------------
 
-    def _import_doc(self):
-        path = filedialog.askopenfilename(title="Import", filetypes=[("Text", "*.txt"), ("All", "*.*")])
-        if not path:
-            return
-        body = Path(path).read_text(encoding="utf-8")
-        title = Path(path).stem
-        nid = self.doc_store.add_document(title, body)
-        self.logger.info(f"Imported {nid}")
-        self._refresh_sidebar()
-        doc = self.doc_store.get_document(nid)
-        if doc:
-            self._render_document(doc)
-
-    def _export_doc(self):
-        """Robust export: picks sensible default extension, writes bytes for binary and text for text."""
-        from tkinter import filedialog, messagebox
-        from pathlib import Path
-
-        if getattr(self, "current_doc_id", None) is None:
-            messagebox.showwarning("Export", "No document selected.")
-            return
-
-        # Fetch and normalize
-        doc = self.doc_store.get_document(self.current_doc_id)
-        if hasattr(doc, "keys"):  # sqlite3.Row-like
-            title = doc["title"] if "title" in doc.keys() else "Document"
-            body = doc["body"] if "body" in doc.keys() else ""
-        elif isinstance(doc, dict):
-            title = doc.get("title") or "Document"
-            body = doc.get("body") or ""
-        else:  # tuple/list row: (id, title, body, ...)
-            title = doc[1] if len(doc) > 1 else "Document"
-            body = doc[2] if len(doc) > 2 else ""
-
-        # Infer extension/filetypes
-        ext = ".txt"
-        filetypes = [("Text", "*.txt"), ("All files", "*.*")]
-        if isinstance(body, (bytes, bytearray)):
-            b = bytes(body)
-            if b.startswith(b"\x89PNG\r\n\x1a\n"):
-                ext, filetypes = ".png", [("PNG image", "*.png"), ("All files", "*.*")]
-            elif b.startswith(b"\xff\xd8\xff"):
-                ext, filetypes = ".jpg", [("JPEG image", "*.jpg;*.jpeg"), ("All files", "*.*")]
-            elif b[:6] in (b"GIF87a", b"GIF89a"):
-                ext, filetypes = ".gif", [("GIF image", "*.gif"), ("All files", "*.*")]
-            elif b.startswith(b"%PDF-"):
-                ext, filetypes = ".pdf", [("PDF", "*.pdf"), ("All files", "*.*")]
-            elif b[:4] == b"RIFF" and b[8:12] == b"WEBP":
-                ext, filetypes = ".webp", [("WebP", "*.webp"), ("All files", "*.*")]
-            else:
-                try:
-                    b.decode("utf-8")
-                    ext, filetypes = ".txt", [("Text", "*.txt"), ("All files", "*.*")]
-                except Exception:
-                    ext, filetypes = ".bin", [("Binary", "*.bin"), ("All files", "*.*")]
-        else:
-            s = (body or "").lstrip()
-            low = s.lower()
-            if low.startswith("<opml"):
-                ext, filetypes = ".opml", [("OPML", "*.opml"), ("XML", "*.xml"), ("All files", "*.*")]
-            elif low.startswith("<html") or ("<body" in low) or ("<div" in low):
-                ext, filetypes = ".html", [("HTML", "*.html;*.htm"), ("All files", "*.*")]
-            elif low.startswith("<svg"):
-                ext, filetypes = ".svg", [("SVG", "*.svg"), ("All files", "*.*")]
-            else:
-                ext, filetypes = ".txt", [("Text", "*.txt"), ("All files", "*.*")]
-
-        # Ask destination
-        safe = "".join(c if (c.isalnum() or c in "._- ") else "_" for c in (title or "Document")).strip() or "Document"
-        path = filedialog.asksaveasfilename(
-            title="Export Document",
-            defaultextension=ext,
-            initialfile=f"{safe}{ext}",
-            filetypes=filetypes,
-        )
-        if not path:
-            return
-
-        # Write
-        try:
-            Path(path).parent.mkdir(parents=True, exist_ok=True)
-            if isinstance(body, (bytes, bytearray)) and ext not in (".txt", ".opml", ".html", ".svg", ".xml"):
-                Path(path).write_bytes(bytes(body))
-            else:
-                if isinstance(body, (bytes, bytearray)):
-                    # Convert bytes→text if the user chose a texty extension
-                    try:
-                        text_out = body.decode("utf-8")
-                    except Exception:
-                        try:
-                            from modules.hypertext_parser import render_binary_as_text
-                            text_out = render_binary_as_text(body, title or "Document")
-                        except Exception:
-                            text_out = body.decode("utf-8", errors="replace")
-                    Path(path).write_text(text_out, encoding="utf-8", newline="\n")
-                else:
-                    Path(path).write_text(body or "", encoding="utf-8", newline="\n")
-            messagebox.showinfo("Export", f"Saved:\n{path}")
-        except Exception as e:
-            messagebox.showerror("Export", f"Could not save:\n{e}")
-
-    def _import_directory(self):
-        dir_path = filedialog.askdirectory(title="Select Folder to Import")
-        if not dir_path:
-            return
-        imported, skipped = import_text_files_from_directory(dir_path, self.doc_store)
-        msg = f"Imported {imported} file(s), skipped {skipped}."
-        print("[INFO]", msg)
-        messagebox.showinfo("Directory Import", msg)
-        self._refresh_sidebar()
-
-    def export_and_launch_server(self):
-        export_path = Path("exported_docs")
-        export_path.mkdir(exist_ok=True)
-        for doc in self.doc_store.get_document_index():
-            data = dict(self.doc_store.get_document(doc["id"]))
-            if data:
-                data = sanitize_doc(data)
-                with open(export_path / f"{data['id']}.json", "w", encoding="utf-8") as f:
-                    json.dump(data, f, indent=2)
-
-        def launch():
-            fp = Path("modules") / "flask_server.py"
-            if fp.exists():
-                subprocess.Popen([sys.executable, str(fp)])
-
-        threading.Thread(target=launch, daemon=True).start()
-        messagebox.showinfo("Server Started", "Flask server launched at http://127.0.0.1:5050")
-
-    def _save_binary_as_text(self):
-        selected_item = self.sidebar.selection()
-        if not selected_item:
-            return
-        doc_id_str = self.sidebar.item(selected_item, "values")[0]
-        if not str(doc_id_str).isdigit():
-            print(f"Warning: selected text is not a valid integer '{doc_id_str}'")
-            return
-        doc_id = int(doc_id_str)
-        doc = self.doc_store.get_document(doc_id)
-        if not doc or len(doc) < 3:
-            return
-        body = doc[2]
-        if isinstance(body, bytes) or ("\x00" in str(body)):
-            print("Binary detected, converting to text using render_binary_as_text.")
-            body = render_binary_as_text(body)
-            self.doc_store.update_document(doc_id, body)
-            self._render_document(self.doc_store.get_document(doc_id))
-        else:
-            print("Document is already text. Skipping overwrite.")
-        content = self.processor.get_strings_content(doc_id)
-        self.doc_store.update_document(doc_id, content)
-        doc = self.doc_store.get_document(doc_id)
-        self._render_document(doc)
-
     # ---------------- Open OPML (import) ----------------
 
-    def _open_opml_from_main(self):
-        path = filedialog.askopenfilename(
-            title="Open OPML/XML", filetypes=[("OPML / XML", "*.opml *.xml"), ("All files", "*.*")]
-        )
-        if not path:
-            return
-        try:
-            content = Path(path).read_text(encoding="utf-8", errors="replace")
-        except Exception as e:
-            messagebox.showerror("Open OPML", f"Failed to read file:\n{e}")
-            return
-        title = Path(path).stem
-        try:
-            new_id = self.doc_store.add_document(title, content)
-        except Exception as e:
-            messagebox.showerror("Open OPML", f"Failed to import OPML to DB:\n{e}")
-            return
-        self._refresh_sidebar()
-        self.current_doc_id = new_id
-        doc = self.doc_store.get_document(new_id)
-        if doc:
-            self._render_document(doc)
-        if getattr(self, "tree_win", None) and self.tree_win.winfo_exists():
-            try:
-                self.tree_win.load_opml_file(path)
-                self.tree_win.deiconify()
-                self.tree_win.lift()
-                self._apply_opml_expand_depth()
-            except Exception:
-                pass
 
     # ---------------- Rendering ----------------
 
 
 
     def _render_document(self, doc):
         """Render a document with content-type aware behavior (LOCAL ONLY for images).
         - text/opml → outline in the text pane
         - image/*   → inline via Pillow (no API calls)
         - default   → text + green-link parsing
         """
         import tkinter as tk
 
         if isinstance(doc, dict):
             body  = doc.get("body")
             ctype = (doc.get("content_type") or "").lower()
             title = doc.get("title") or ""
             doc_id = doc.get("id")
         else:
             body  = doc[2] if len(doc) > 2 else ""
             ctype = ""
             title = doc[1] if len(doc) > 1 else ""
             doc_id = doc[0] if len(doc) > 0 else None
 
         # OPML
diff --git a/modules/gui_tkinter.py b/modules/gui_tkinter.py
index de360b1c70086840f3bb52420ec88635c5d78e78..cb875c7895b1ebc3462111db4a74b1e527ef40bf 100644
--- a/modules/gui_tkinter.py
+++ b/modules/gui_tkinter.py
@@ -980,43 +801,26 @@ class DemoKitGUI(tk.Tk):
             nid = int(vals[0])
         except (ValueError, TypeError):
             messagebox.showerror("Delete", "Invalid document ID.")
             return
         if not messagebox.askyesno("Confirm Delete", f"Delete document ID {nid}?"):
             return
         try:
             self.doc_store.delete_document(nid)
         except Exception as e:
             messagebox.showerror("Delete", f"Failed to delete: {e}")
             return
         # Clear UI
         self._refresh_sidebar()
         self.text.delete("1.0", tk.END)
         if hasattr(self, "_opml_frame") and self._opml_frame.winfo_exists():
             self._opml_frame.grid_remove()
         if hasattr(self, "img_label"):
             self.img_label.configure(image="")
         self.current_doc_id = None
         self._last_pil_img = None
         self._last_tk_img = None
         self._image_enlarged = False
         messagebox.showinfo("Deleted", f"Document {nid} has been deleted.")
 
 
-def sanitize_doc(doc):
-    """
-    Normalize doc['body'] only for textual content.
-    Leave image/other binary bodies as bytes so the GUI can render them.
-    """
-    if not isinstance(doc, dict):
-        return doc
-    body = doc.get("body")
-    ctype = (doc.get("content_type") or "").lower()
-    if isinstance(body, (bytes, bytearray)):
-        if ctype.startswith("image/") or ctype in ("application/octet-stream",):
-            return doc
-        try:
-            doc["body"] = body.decode("utf-8")
-        except UnicodeDecodeError:
-            doc["body"] = body.decode("latin-1", errors="replace")
-    return doc
 

